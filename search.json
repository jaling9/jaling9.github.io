[{"title":"DNS查询原理入门-阮一峰","url":"/2022/11/21/DNS%20%E6%9F%A5%E8%AF%A2%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%20-%20%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2022/08/dns-query.html\n\n通过 DNS 查询，得到域名的 IP 地址，才能访问网站。\n那么，DNS 查询到底是怎么完成的？本文通过实例，详细介绍背后的步骤。\n\n一、DNS 服务器域名对应的 IP 地址，都保存在 DNS 服务器。\n我们输入域名，浏览器就会在后台，自动向 DNS 服务器发出请求，获取对应的 IP 地址。这就是 DNS 查询。\n\n举例来说，我输入 es6.ruanyifeng.com 这个域名，浏览器就要向 DNS 服务器查询，它的 IP 地址是什么，然后向该 IP 发出访问请求。\n网上有很多公用的 DNS 服务器，这篇文章选择 Cloudflare 公司提供的 1.1.1.1 进行演示。\n\n二、dig 命令命令行工具 dig 可以跟 DNS 服务器互动，我们就用它演示 DNS 查询。如果你还没有安装，可以搜一下安装方法，在 Linux 系统下是非常容易的。\n它的查询语法如下（美元符号$是命令行提示符）。\n\n\n$ dig @[DNS 服务器] [域名]\n\n向 1.1.1.1 查询域名，就执行下面的命令。\n\n\n$ dig @1.1.1.1 es6.ruanyifeng.com\n\n正常情况下，它会输出一大堆内容。\n\n在其中找到 ANSWER SECTION 这个部分，它给出了查询的答案，域名对应的 IP 地址是 104.198.14.52。\n三、域名的树状结构你可能会问，难道 DNS 服务器（比如 1.1.1.1）保存了世界上所有域名（包括二级域名、三级域名）的 IP 地址？\n当然不是。DNS 是一个分布式系统，1.1.1.1 只是用户查询入口，它也需要再向其他 DNS 服务器查询，才能获得最终的 IP 地址。\n要说清楚 DNS 完整的查询过程，就必须了解 域名是一个树状结构。\n最顶层的域名是根域名（root），然后是顶级域名（top-level domain，简写 TLD），再是一级域名、二级域名、三级域名。\n\n（1）根域名\n所有域名的起点都是根域名，它写作一个点.，放在域名的结尾。因为这部分对于所有域名都是相同的，所以就省略不写了，比如example.com等同于example.com.（结尾多一个点）。\n你可以试试，任何一个域名结尾加一个点，浏览器都可以正常解读。\n（2）顶级域名\n根域名的下一级是顶级域名。它分成两种：通用顶级域名（gTLD，比如 .com 和 .net）和国别顶级域名（ccTLD，比如 .cn 和 .us）。\n顶级域名由国际域名管理机构 ICANN 控制，它委托商业公司管理 gTLD，委托各国管理自己的国别域名。\n（3）一级域名\n一级域名就是你在某个顶级域名下面，自己注册的域名。比如，ruanyifeng.com就是我在顶级域名.com下面注册的。\n（4）二级域名\n二级域名是一级域名的子域名，是域名拥有者自行设置的，不用得到许可。比如，es6 就是 ruanyifeng.com 的二级域名。\n四、域名的逐级查询这种树状结构的意义在于，只有上级域名，才知道下一级域名的 IP 地址，需要逐级查询。\n每一级域名都有自己的 DNS 服务器，存放下级域名的 IP 地址。\n所以，如果想要查询二级域名 es6.ruanyifeng.com 的 IP 地址，需要三个步骤。\n\n第一步，查询根域名服务器，获得顶级域名服务器.com（又称 TLD 服务器）的 IP 地址。\n第二步，查询 TLD 服务器 .com，获得一级域名服务器 ruanyifeng.com 的 IP 地址。\n第三步，查询一级域名服务器 ruanyifeng.com，获得二级域名 es6 的 IP 地址。\n\n下面依次演示这三个步骤。\n五、根域名服务器根域名服务器全世界一共有13台（都是服务器集群）。它们的域名和 IP 地址如下。\n\n根域名服务器的 IP 地址是不变的，集成在操作系统里面。\n操作系统会选其中一台，查询 TLD 服务器的 IP 地址。\n\n\n$ dig @192.33.4.12 es6.ruanyifeng.com\n\n上面示例中，我们选择192.33.4.12，向它发出查询，询问es6.ruanyifeng.com的 TLD 服务器的 IP 地址。\ndig 命令的输出结果如下。\n\n因为它给不了 es6.ruanyifeng.com 的 IP 地址，所以输出结果中没有 ANSWER SECTION，只有一个 AUTHORITY SECTION，给出了com.的13台 TLD 服务器的域名。\n下面还有一个 ADDITIONAL SECTION，给出了这13台 TLD 服务器的 IP 地址（包含 IPv4 和 IPv6 两个地址）。\n六、TLD 服务器有了 TLD 服务器的 IP 地址以后，我们再选一台接着查询。\n\n\n$ dig @192.41.162.30 es6.ruanyifeng.com\n\n上面示例中，192.41.162.30 是随便选的一台 .com 的 TLD 服务器，我们向它询问 es6.ruanyifeng.com 的 IP 地址。\n返回结果如下。\n\n它依然没有 ANSWER SECTION 的部分，只有 AUTHORITY SECTION，给出了一级域名 ruanyifeng.com 的两台 DNS 服务器。\n下面的 ADDITIONAL SECTION 就是这两台 DNS 服务器对应的 IP 地址。\n七、一级域名的 DNS 服务器第三步，再向一级域名的 DNS 服务器查询二级域名的 IP 地址。\n\n\n$ dig @172.64.32.123 es6.ruanyifeng.com\n\n返回结果如下。\n\n这次终于有了 ANSWER SECTION，得到了最终的二级域名的 IP 地址。\n至此，三个步骤的 DNS 查询全部完成。\n八、DNS 服务器的种类总结一下，上面一共提到了四种服务器。\n\n\n1.1.1.1\n根域名服务器\nTLD 服务器\n一级域名服务器\n\n\n它们都属于 DNS 服务器，都用来接受 DNS 查询。但是作用不一样，属于不同的类别。\n8.1 递归 DNS 服务器后三种服务器只用来查询下一级域名的 IP 地址，而 1.1.1.1 则把分步骤的查询过程自动化，方便用户一次性得到结果，所以它称为递归 DNS 服务器（recursive DNS server），即可以自动递归查询。\n我们平常说的 DNS 服务器，一般都是指递归 DNS 服务器。它把 DNS 查询自动化了，只要向它查询就可以了。\n它内部有缓存，可以保存以前查询的结果，下次再有人查询，就直接返回缓存里面的结果。所以它能加快查询，减轻源头 DNS 服务器的负担。\n8.2 权威 DNS 服务器一级域名服务器的正式名称叫做权威域名服务器（Authoritative Name Server）。\n“权威”的意思是域名的 IP 地址由它给定，不像递归服务器自己做不了主。我们购买域名后，设置 DNS 服务器就是在设置该域名的权威服务器。\n8.3 四种 DNS 服务器综上所述，DNS 服务器可以分成四种：\n\n\n根域名服务器\nTLD 服务器\n权威域名服务器\n递归域名服务器\n\n\n它们的关系如下图。\n\n知道了 DNS 查询的原理，完全可以自己写一个 DNS 的递归服务器，这是不难的。网上有很多参考资料，有兴趣的话，大家可以试试看。\n\n九、参考网址\nBuilding a Recursive DNS Resolver, Timothy Andrew\nAuthoritative Vs Recursive DNS: What You Need To Know, Serena Raymond\nDNS 服务器类型，Cloudflare\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"DNS原理入门-阮一峰","url":"/2022/11/21/DNS%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2016/06/dns.html\n\nDNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。\n本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS。\n\n一、DNS 是什么？DNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。\n举例来说，如果你要访问域名math.stackexchange.com，首先要通过DNS查出它的IP地址是151.101.129.69。\n如果你不清楚为什么一定要查出IP地址，才能进行网络通信，建议先阅读我写的《互联网协议入门》。\n二、查询过程虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。\n工具软件dig可以显示整个查询过程。\n\n\n$ dig math.stackexchange.com\n\n上面的命令会输出六段信息。\n\n第一段是查询参数和统计。\n\n第二段是查询内容。\n\n上面结果表示，查询域名math.stackexchange.com的A记录，A是address的缩写。\n第三段是DNS服务器的答复。\n\n上面结果显示，math.stackexchange.com有四个A记录，即四个IP地址。600是TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。\n第四段显示stackexchange.com的NS记录（Name Server的缩写），即哪些服务器负责管理stackexchange.com的DNS记录。\n\n上面结果显示stackexchange.com共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道math.stackexchange.com的IP地址是什么。\n第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的。\n\n第六段是DNS服务器的一些传输信息。\n\n上面结果显示，本机的DNS服务器是192.168.1.253，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。\n如果不想看到这么多内容，可以使用+short参数。\n\n\n$ dig +short math.stackexchange.com\n\n151.101.129.69\n151.101.65.69\n151.101.193.69\n151.101.1.69\n\n上面命令只返回math.stackexchange.com对应的4个IP地址（即A记录）。\n三、DNS服务器下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名math.stackexchange.com的IP地址。\n首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。\n\nDNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。\n上例的DNS服务器是192.168.1.253，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的8.8.8.8和Level 3的4.2.2.2。\n本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。\n\n\n$ dig @4.2.2.2 math.stackexchange.com\n\n上面命令指定向DNS服务器4.2.2.2查询。\n四、域名的层级DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。\n请仔细看前面的例子，每个域名的尾部都多了一个点。\n\n比如，域名math.stackexchange.com显示为math.stackexchange.com.。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。\n举例来说，www.example.com真正的域名是www.example.com.root，简写为www.example.com.。因为，根域名.root对于所有域名都是一样的，所以平时是省略的。\n根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如.com、.net；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如www.example.com里面的.example，这一级域名是用户可以注册的；再下一级是主机名（host），比如www.example.com里面的www，又称为”三级域名”，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。\n总结一下，域名的层级结构如下。\n\n\n主机名.次级域名.顶级域名.根域名\n\n# 即\n\nhost.sld.tld.root\n\n五、根域名服务器DNS服务器根据域名的层级，进行分级查询。\n需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。\n所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。\n\n\n从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址）\n从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址）\n从”次级域名服务器”查出”主机名”的IP地址\n\n\n仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道”根域名服务器”的IP地址。回答是”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。\n下面是内置的根域名服务器IP地址的一个例子。\n\n上面列表中，列出了根域名（.root）的三条NS记录A.ROOT-SERVERS.NET、B.ROOT-SERVERS.NET和C.ROOT-SERVERS.NET，以及它们的IP地址（即A记录）198.41.0.4、192.228.79.201、192.33.4.12。\n另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。\n目前，世界上一共有十三组根域名服务器，从A.ROOT-SERVERS.NET一直到M.ROOT-SERVERS.NET。\n六、分级查询的实例dig命令的+trace参数可以显示DNS的整个分级查询过程。\n\n\n$ dig +trace math.stackexchange.com\n\n上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器。\n\n根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问math.stackexchange.com的顶级域名服务器com.的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。\n接着是第二段。\n\n上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。\n然后，DNS服务器向这些顶级域名服务器发出查询请求，询问math.stackexchange.com的次级域名stackexchange.com的NS记录。\n\n上面结果显示stackexchange.com有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。\n然后，DNS服务器向上面这四台NS服务器查询math.stackexchange.com的主机名。\n\n上面结果显示，math.stackexchange.com有4条A记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是ns-463.awsdns-57.com，IP地址为205.251.193.207。\n七、NS 记录的查询dig命令可以单独查看每一级域名的NS记录。\n\n\n$ dig ns com\n$ dig ns stackexchange.com\n\n+short参数可以显示简化的结果。\n\n\n$ dig +short ns com\n$ dig +short ns stackexchange.com\n\n八、DNS的记录类型域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type），前面已经看到了有A记录和NS记录。\n常见的DNS记录类型如下。\n\n（1） A：地址记录（Address），返回域名指向的IP地址。\n（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。\n（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。\n（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。\n（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。\n\n一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。\nCNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，facebook.github.io这个域名就是一个CNAME记录。\n\n\n$ dig facebook.github.io\n\n...\n\n;; ANSWER SECTION:\nfacebook.github.io. 3370    IN  CNAME   github.map.fastly.net.\ngithub.map.fastly.net.  600 IN  A   103.245.222.133\n\n上面结果显示，facebook.github.io的CNAME记录指向github.map.fastly.net。也就是说，用户查询facebook.github.io的时候，实际上返回的是github.map.fastly.net的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改github.map.fastly.net这个域名就可以了，用户的facebook.github.io域名不用修改。\n由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，foo.com指向bar.com，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。\nPTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录。\n\n\n$ dig -x 192.30.252.153\n\n...\n\n;; ANSWER SECTION:\n153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.\n\n上面结果显示，192.30.252.153这台服务器的域名是pages.github.com。\n逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。\ndig命令可以查看指定的记录类型。\n\n\n$ dig a github.com\n$ dig ns github.com\n$ dig mx github.com\n\n九、其他DNS工具除了dig，还有一些其他小工具也可以使用。\n（1）host 命令\nhost命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。\n\n\n$ host github.com\n\ngithub.com has address 192.30.252.121\ngithub.com mail is handled by 5 ALT2.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 10 ALT4.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 10 ALT3.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 5 ALT1.ASPMX.L.GOOGLE.COM.\ngithub.com mail is handled by 1 ASPMX.L.GOOGLE.COM.\n\n$ host facebook.github.com\n\nfacebook.github.com is an alias for github.map.fastly.net.\ngithub.map.fastly.net has address 103.245.222.133\n\nhost命令也可以用于逆向查询，即从IP地址查询域名，等同于dig -x &lt;ip&gt;。\n\n\n$ host 192.30.252.153\n\n153.252.30.192.in-addr.arpa domain name pointer pages.github.com.\n\n（2）nslookup 命令\nnslookup命令用于互动式地查询域名记录。\n\n\n$ nslookup\n\n&gt; facebook.github.io\nServer:     192.168.1.253\nAddress:    192.168.1.253#53\n\nNon-authoritative answer:\nfacebook.github.io  canonical name &#x3D; github.map.fastly.net.\nName:   github.map.fastly.net\nAddress: 103.245.222.133\n\n&gt; \n\n（3）whois 命令\nwhois命令用来查看域名的注册情况。\n\n\n$ whois github.com\n\n十、参考链接\nDNS: The Good Parts, by Pete Keen\nDNS 101, by Mark McDonnell\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"HTTP 协议入门-阮一峰","url":"/2022/11/21/HTTP%20%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2016/08/http.html\n\nHTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP&#x2F;2 更是让它成为技术热点。\n本文介绍 HTTP 协议的历史演变和设计思路。\n\n一、HTTP&#x2F;0.9HTTP 是基于 TCP&#x2F;IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。\n最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。\n\n\nGET &#x2F;index.html\n\n上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。\n协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。\n\n\n&lt;html&gt;\n  &lt;body&gt;Hello World&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n服务器发送完毕，就关闭TCP连接。\n二、HTTP&#x2F;1.02.1 简介1996年5月，HTTP&#x2F;1.0 版本发布，内容大大增加。\n首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。\n其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。\n再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。\n其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。\n2.2 请求格式下面是一个1.0版的HTTP请求的例子。\n\n\nGET &#x2F; HTTP&#x2F;1.0\nUser-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_10_5)\nAccept: *&#x2F;*\n\n可以看到，这个格式与0.9版有很大变化。\n第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。\n2.3 回应格式服务器的回应如下。\n\n\nHTTP&#x2F;1.0 200 OK \nContent-Type: text&#x2F;plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n\n&lt;html&gt;\n  &lt;body&gt;Hello World&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。\n2.4 Content-Type 字段关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。\n下面是一些常见的Content-Type字段的值。\n\n\ntext&#x2F;plain\ntext&#x2F;html\ntext&#x2F;css\nimage&#x2F;jpeg\nimage&#x2F;png\nimage&#x2F;svg+xml\naudio&#x2F;mp4\nvideo&#x2F;mp4\napplication&#x2F;javascript\napplication&#x2F;pdf\napplication&#x2F;zip\napplication&#x2F;atom+xml\n\n\n这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。\n除了预定义的类型，厂商也可以自定义类型。\n\n\napplication&#x2F;vnd.debian.binary-package\n\n上面的类型表明，发送的是Debian系统的二进制数据包。\nMIME type还可以在尾部使用分号，添加参数。\n\n\nContent-Type: text&#x2F;html; charset&#x3D;utf-8\n\n上面的类型表明，发送的是网页，而且编码是UTF-8。\n客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。\n\n\nAccept: *&#x2F;*\n\n上面代码中，客户端声明自己可以接受任何格式的数据。\nMIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。\n\n\n&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot; &#x2F;&gt;\n&lt;!-- 等同于 --&gt;\n&lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt; \n\n2.5 Content-Encoding 字段由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。\n\n\nContent-Encoding: gzip\nContent-Encoding: compress\nContent-Encoding: deflate\n\n客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。\n\n\nAccept-Encoding: gzip, deflate\n\n2.6 缺点HTTP&#x2F;1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\nTCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。\n\n\nConnection: keep-alive\n\n这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。\n\n\nConnection: keep-alive\n\n一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。\n三、HTTP&#x2F;1.11997年1月，HTTP&#x2F;1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。\n3.1 持久连接1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。\n客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。\n\n\nConnection: close\n\n目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。\n3.2 管道机制1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。\n3.3 Content-Length 字段一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。\n\n\nContent-Length: 3495\n\n上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。\n在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。\n3.4 分块传输编码使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。\n对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。\n因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。\n\n\nTransfer-Encoding: chunked\n\n每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。\n\n\nHTTP&#x2F;1.1 200 OK\nContent-Type: text&#x2F;plain\nTransfer-Encoding: chunked\n\n25\nThis is the data in the first chunk\n\n1C\nand this is the second one\n\n3\ncon\n\n8\nsequence\n\n0\n\n\n3.5 其他功能1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。\n另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。\n\n\nHost: www.example.com\n\n有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。\n3.6 缺点虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。\n为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。\n四、SPDY 协议2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP&#x2F;1.1 效率不高的问题。\n这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP&#x2F;2 的基础，主要特性都在 HTTP&#x2F;2 之中得到继承。\n五、HTTP&#x2F;22015年，HTTP&#x2F;2 发布。它不叫 HTTP&#x2F;2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP&#x2F;3。\n5.1 二进制协议HTTP&#x2F;1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。\n二进制协议的一个好处是，可以定义额外的帧。HTTP&#x2F;2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。\n5.2 多工HTTP&#x2F;2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。\n举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。\n这样双向的、实时的通信，就叫做多工（Multiplexing）。\n5.3 数据流因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。\nHTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。\n数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP&#x2F;2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。\n客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。\n5.4 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。\nHTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n5.5 服务器推送HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。\n常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。\n六、参考链接\nJourney to HTTP&#x2F;2, by Kamran Ahmed\nHTTP, by Wikipedia\nHTTP&#x2F;1.0 Specification\nHTTP&#x2F;2 Specification\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"MVC，MVP 和 MVVM 的图示-阮一峰","url":"/2022/11/21/MVC%EF%BC%8CMVP%20%E5%92%8C%20MVVM%20%E7%9A%84%E5%9B%BE%E7%A4%BA-%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"复杂的软件必须有清晰合理的架构，否则无法开发和维护。\nMVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。\n昨天晚上，我读了《Scaling Isomorphic Javascript Code》，突然意识到，它们的区别非常简单。我用几段话，就可以说清。\n\n（题图：摄于瓦伦西亚，西班牙，2014年8月）\n一、MVCMVC模式的意思是，软件可以分成三个部分。\n\n\n\n视图（View）：用户界面。\n控制器（Controller）：业务逻辑\n模型（Model）：数据保存\n\n\n各部分之间的通信方式如下。\n\n\n\nView 传送指令到 Controller\nController 完成业务逻辑后，要求 Model 改变状态\nModel 将新的数据发送到 View，用户得到反馈\n\n\n所有通信都是单向的。\n二、互动模式接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。\n\n另一种是直接通过controller接受指令。\n\n三、实例：Backbone实际项目往往采用更灵活的方式，以 Backbone.js 为例。\n\n1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。\n2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。\n3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。\n四、MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。\n\n1. 各部分之间的通信，都是双向的。\n2. View 与 Model 不发生联系，都通过 Presenter 传递。\n3. View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。\n五、MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。\n\n唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。\n（完）\n","categories":["开发"],"tags":["转载"]},{"title":"HTTP/2 协议入门-阮一峰","url":"/2022/11/21/HTTPS%20%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97-%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2016/08/migrate-from-http-to-https.html\n\n上一篇文章我介绍了 HTTP&#x2F;2 协议 ，它只有在 HTTPS 环境才会生效。\n为了升级到 HTTP&#x2F;2 协议，必须先启用 HTTPS。如果你不了解 HTTPS 协议（学名 TLS 协议），可以参考我以前的文章。\n\n\n《HTTPS 协议概述》\n《图解 HTTPS 协议》\n《HTTPS 协议的七个误解》\n《HTTPS 协议的延迟有多大？》\n\n\n本文介绍如何将一个 HTTP 网站升级到 HTTPS 。\n\n一、获取证书升级到 HTTPS 协议的第一步，就是要获得一张证书。\n证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，要从经销商购买。\n\n\nGoGetSSL\nSSLs.com\nSSLmate.com\n\n\n证书有很多类型，首先分为三种认证级别。\n\n\n\n域名认证（Domain Validation）：最低级别认证，可以确认申请人拥有这个域名。对于这种证书，浏览器会在地址栏显示一把锁。\n公司认证（Company Validation）：确认域名所有人是哪一家公司，证书里面会包含公司信息。\n扩展认证（Extended Validation）：最高级别的认证，浏览器地址栏会显示公司名。\n\n\n还分为三种覆盖范围。\n\n\n单域名证书：只能用于单一域名，foo.com的证书不能用于www.foo.com\n通配符证书：可以用于某个域名及其所有一级子域名，比如*.foo.com的证书可以用于foo.com，也可以用于www.foo.com\n多域名证书：可以用于多个域名，比如foo.com和bar.com\n\n\n认证级别越高、覆盖范围越广的证书，价格越贵。\n还有一个免费证书的选择。为了推广HTTPS协议，电子前哨基金会EFF成立了 Let’s Encrypt，提供免费证书（教程和工具）。\n拿到证书以后，可以用 SSL Certificate Check 检查一下，信息是否正确。\n二、安装证书证书可以放在/etc/ssl目录（Linux 系统），然后根据你使用的Web服务器进行配置。\n\n\n证书配置文件生成器，by Mozilla\n配置文件模板，by SSLMate\n\n\n如果使用 Let’s Encrypt 证书，请使用自动安装工具 Certbot。\n安装成功后，使用 SSL Labs Server Test 检查一下证书是否生效。\n三、修改链接下一步，网页加载的 HTTP 资源，要全部改成 HTTPS 链接。因为加密网页内如果有非加密的资源，浏览器是不会加载那些资源的。\n\n\n&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;foo.com&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n上面这行加载命令，有两种改法。\n\n\n&lt;!-- 改法一 --&gt;\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;foo.com&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n&lt;!-- 改法二 --&gt;\n&lt;script src&#x3D;&quot;&#x2F;&#x2F;foo.com&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n\n其中，改法二会根据当前网页的协议，加载相同协议的外部资源，更灵活一些。\n另外，如果页面头部用到了rel=&quot;canonical&quot;，也要改成HTTPS网址。\n\n\n&lt;link rel&#x3D;&quot;canonical&quot; href&#x3D;&quot;https:&#x2F;&#x2F;foo.com&#x2F;bar.html&quot; &#x2F;&gt;\n\n四、301重定向下一步，修改 Web 服务器的配置文件，使用 301 重定向，将 HTTP 协议的访问导向 HTTPS 协议。\nNginx 的写法。\n\n\nserver &#123;\n  listen 80;\n  server_name domain.com www.domain.com;\n  return 301 https:&#x2F;&#x2F;domain.com$request_uri;\n&#125;\n\nApache 的写法（.htaccess文件）。\n\n\nRewriteEngine On\nRewriteCond %&#123;HTTPS&#125; off\nRewriteRule (.*) https:&#x2F;&#x2F;%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R&#x3D;301,L]\n\n五、安全措施以下措施可以进一步保证通信安全。\n5.1 HTTP Strict Transport Security (HSTS)访问网站时，用户很少直接在地址栏输入https://，总是通过点击链接，或者3xx重定向，从HTTP页面进入HTTPS页面。攻击者完全可以在用户发出HTTP请求时，劫持并篡改该请求。\n另一种情况是恶意网站使用自签名证书，冒充另一个网站，这时浏览器会给出警告，但是许多用户会忽略警告继续访问。\n“HTTP严格传输安全”（简称 HSTS）的作用，就是强制浏览器只能发出HTTPS请求，并阻止用户接受不安全的证书。\n它在网站的响应头里面，加入一个强制性声明。以下例子摘自维基百科。\n\n\nStrict-Transport-Security: max-age&#x3D;31536000; includeSubDomains\n\n上面这段头信息有两个作用。\n\n（1）在接下来的一年（即31536000秒）中，浏览器只要向example.com或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。用户点击超链接或在地址栏输入http://www.example.com/，浏览器应当自动将http转写成https，然后直接向https://www.example.com/发送请求。\n（2）在接下来的一年中，如果example.com服务器发送的证书无效，用户不能忽略浏览器警告，将无法继续访问该网站。\n\nHSTS 很大程度上解决了 SSL 剥离攻击。只要浏览器曾经与服务器建立过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。\n该方法的主要不足是，用户首次访问网站发出HTTP请求时，是不受HSTS保护的。\n如果想要全面分析网站的安全程度，可以使用 Mozilla 的 Observatory。\n5.2 Cookie另一个需要注意的地方是，确保浏览器只在使用 HTTPS 时，才发送Cookie。\n网站响应头里面，Set-Cookie字段加上Secure标志即可。\n\n\nSet-Cookie: LSID&#x3D;DQAAAK...Eaem_vYg; Secure\n\n六、参考链接\nHow To Migrate To HTTPS, by Chris Palmer\nComplete Guide - How to Migrate from HTTP to HTTPS, by KeyCDN\nWhat You Need to Know About Changing From Http to Https, by Matt Mansfield\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"Markdown语法","url":"/2022/11/12/Markdown%E8%AF%AD%E6%B3%95/","content":"表格\n\n\nSyntax\nDescription\n\n\n\nHeader\nTitle\n\n\nParagraph\nText\n\n\n\n\n\nSyntax\nDescription\n\n\n\nHeader\nTitle\n\n\nParagraph\nText\n\n\n任务列表\n Write the press release\n Update the website\n Contact the media\n\n表情符号sfs :unamused:\n行内标签&#123;% label primary @text %&#125;\n&lt;span class&#x3D;&quot;label label-primary&quot;&gt;Label&lt;&#x2F;span&gt;\n可选类别：primary default info success warning danger\n\nLabel\n参考脚注这是一句话[1]\n便签\n可选类别  primary  secondary  success  danger  warning  info  light\n\n&#123;% note success %&#125;\n文字 或者 &#96;markdown&#96; 均可\n&#123;% endnote %&#125;\n\n\n            两种方式：上面是第一种方式，下面是html方法\n          \n\n&lt;p class=\"note note-danger\">便签&lt;/p>\n\n便签\n\n\n按钮&#123;% btn url, text, title %&#125;或者\n&lt;a class&#x3D;&quot;btn&quot; href&#x3D;&quot;https:&#x2F;&#x2F;hexo.fluid-dev.com&#x2F;docs&#x2F;guide&#x2F;#tag-%E6%8F%92%E4%BB%B6&quot; title&#x3D;&quot;title&quot;&gt;tag&lt;&#x2F;a&gt;\ntext\ntag这是对应的脚注 ↩参考资料1 ↩参考资料2 ↩\n","categories":["其他"],"tags":["原创","markdown"]},{"title":"MySQL优化","url":"/2022/11/15/MySQL%E4%BC%98%E5%8C%96/","content":"\n有情怀，有干货，微信搜索【三太子敖丙】关注这个不一样的程序员。\n本文 GitHub github.com&#x2F;JavaFamily 已收录，有一线大厂面试完整考点、资料以及我的系列文章。原文链接:https://juejin.cn/post/6895507965899063310#heading-1\n\n前言这天我正在午休呢，公司DBA就把我喊醒了，说某库出现大量慢SQL，很快啊，很快，我还没反应过来，库就挂了，我心想现在的用户不讲武德啊，怎么在我睡觉的时候大量请求呢。\n这是很常见的一个场景哈，因为很多业务开始数据量级不大，所以写sql的时候就没注意性能，等量级上去，很多业务就需要做调优了，在电商公司工作的这几年我也总结了不少，下面就分享给大家吧。\n在代码开发过程中，我们都会遵循一些SQL开发规范去编写高质量SQL，来提高接口的Response Time(RT)，对一些核心接口要求RT在100ms以内甚至更低。\n由于业务前期数据量比较小，基本都能满足这个要求，但随着业务量的增长，数据量也随之增加，对应接口的SQL耗时也在变长，直接影响了用户的体验，这时候就需要对SQL进行优化。\n优化点主要包括SQL规范性检查，表结构索引检查，SQL优化案例分析，下面从这三方面结合实际案例聊聊如何优化SQL。\nSQL规范性检查每个公司都有自己的MySQL开发规范，基本上大同小异，这里罗列一些比较重要的，我工作期间经常接触的给大家。\nselect检查UDF用户自定义函数\nSQL语句的select后面使用了自定义函数UDF，SQL返回多少行，那么UDF函数就会被调用多少次，这是非常影响性能的。\n#getOrderNo是用户自定义一个函数用户来根据order_sn来获取订单编号\nselect id, payment_id, order_sn, getOrderNo(order_sn) \nfrom payment_transaction \nwhere status &#x3D; 1 and create_time \nbetween &#39;2020-10-01 10:00:00&#39; and &#39;2020-10-02 10:00:00&#39;;\n\ntext类型检查\n如果select出现text类型的字段，就会消耗大量的网络和IO带宽，由于返回的内容过大超过max_allowed_packet设置会导致程序报错，需要评估谨慎使用。\n#表request_log的中content是text类型。\nselect user_id, content, status, url, type \nfrom request_log \nwhere user_id &#x3D; 32121;\n\ngroup_concat谨慎使用\ngorup_concat是一个字符串聚合函数，会影响SQL的响应时间，如果返回的值过大超过了max_allowed_packet设置会导致程序报错。\nselect batch_id, group_concat(name) from buffer_batch \nwhere status &#x3D; 0 and create_time \nbetween &#39;2020-10-01 10:00:00&#39; and &#39;2020-10-02 10:00:00&#39;;\n\n内联子查询\n在select后面有子查询的情况称为内联子查询，SQL返回多少行，子查询就需要执行过多少次，严重影响SQL性能。\nselect id,(select rule_name from member_rule limit 1) as rule_name, member_id, member_type, member_name, status  \nfrom member_info m \nwhere status &#x3D; 1 and create_time \nbetween &#39;2020-09-02 10:00:00&#39; and &#39;2020-10-01 10:00:00&#39;;\n\nfrom检查表的链接方式\n在MySQL中不建议使用Left Join，即使ON过滤条件列索引，一些情况也不会走索引，导致大量的数据行被扫描，SQL性能变得很差，同时要清楚ON和Where的区别。\nSELECT a.member_id,a.create_time,b.active_time \nFROM operation_log a \nLEFT JOIN member_info b ON a.member_id &#x3D; b.member_id \nwhere  b.&#96;status&#96; &#x3D; 1\nand a.create_time \nbetween &#39;2020-10-01 00:00:00&#39; \nand &#39;2020-10-30 00:00:00&#39; \nlimit 100, 0;\n\n子查询\n由于MySQL的基于成本的优化器CBO对子查询的处理能力比较弱，不建议使用子查询，可以改写成Inner Join。\nselect b.member_id,b.member_type, a.create_time,a.device_model \nfrom member_operation_log a \ninner join (select member_id,member_type from member_base_info where &#96;status&#96; &#x3D; 1\nand create_time between &#39;2020-10-01 00:00:00&#39; and &#39;2020-10-30 00:00:00&#39;) \nas b on a.member_id &#x3D; b.member_id;\n\nwhere检查索引列被运算\n当一个字段被索引，同时出现where条件后面，是不能进行任何运算，会导致索引失效。\n#device_no列上有索引，由于使用了ltrim函数导致索引失效\nselect id, name , phone, address, device_no \nfrom users where ltrim(device_no) &#x3D; &#39;Hfs1212121&#39;;\n#balance列有索引,由于做了运算导致索引失效\nselect account_no, balance from accounts \nwhere balance + 100 &#x3D; 10000 \nand status &#x3D; 1;\n\n类型转换\n对于Int类型的字段，传varchar类型的值是可以走索引，MySQL内部自动做了隐式类型转换；相反对于varchar类型字段传入Int值是无法走索引的，应该做到对应的字段类型传对应的值总是对的。\n#user_id是bigint类型，传入varchar值发生了隐式类型转换，可以走索引。\nselect id, name , phone, address, device_no \nfrom users where user_id &#x3D; &#39;23126&#39;;\n#card_no是varchar(20)，传入int值是无法走索引\nselect id, name , phone, address, device_no \nfrom users \nwhere card_no &#x3D; 2312612121;\n\n列字符集\n从MySQL 5.6开始建议所有对象字符集应该使用用utf8mb4，包括MySQL实例字符集，数据库字符集，表字符集，列字符集。避免在关联查询Join时字段字符集不匹配导致索引失效，同时目前只有utf8mb4支持emoji表情存储。\ncharacter_set_server  &#x3D;  utf8mb4    #数据库实例字符集\ncharacter_set_connection &#x3D; utf8mb4  #连接字符集\ncharacter_set_database &#x3D; utf8mb4    #数据库字符集\ncharacter_set_results &#x3D; utf8mb4     #结果集字符集\n\ngroup by检查前缀索引\ngroup by后面的列有索引，索引可以消除排序带来的CPU开销，如果是前缀索引，是不能消除排序的。\n#device_no字段类型varchar(200)，创建了前缀索引。\nmysql&gt; alter table users add index idx_device_no(device_no(64));\n\nmysql&gt; select device_no, count(*) from users where create_time between &#39;2020-10-01 00:00:00&#39; and &#39;2020-10-30 00:00:00&#39; group by device_no;\n\n函数运算\n假设需要统计某月每天的新增用户量，参考如下SQL语句，虽然可以走create_time的索引，但是不能消除排序，可以考虑冗余一个字段stats_date date类型来解决这种问题。\nselect DATE_FORMAT(create_time, &#39;%Y-%m-%d&#39;), count(*) \nfrom users where create_time \nbetween &#39;2020-09-01 00:00:00&#39; and &#39;2020-09-30 23:59:59&#39; \ngroup by DATE_FORMAT(create_time, &#39;%Y-%m-%d&#39;);\n\norder by检查前缀索引\norder by后面的列有索引，索引可以消除排序带来的CPU开销，如果是前缀索引，是不能消除排序的。\n字段顺序\n排序字段顺序，asc&#x2F;desc升降要跟索引保持一致，充分利用索引的有序性来消除排序带来的CPU开销。\nlimit检查limit m,n要慎重\n对于limit m, n分页查询，越往后面翻页即m越大的情况下SQL的耗时会越来越长，对于这种应该先取出主键id，然后通过主键id跟原表进行Join关联查询。\n表结构检查表&amp;列名关键字在数据库设计建模阶段，对表名及字段名设置要合理，不能使用MySQL的关键字，如desc, order, status, group等。同时建议设置lower_case_table_names &#x3D; 1表名不区分大小写。\n表存储引擎对于OLTP业务系统，建议使用InnoDB引擎获取更好的性能，可以通过参数default_storage_engine控制。\nAUTO_INCREMENT属性建表的时候主键id带有AUTO_INCREMENT属性，而且AUTO_INCREMENT&#x3D;1，在InnoDB内部是通过一个系统全局变量dict_sys.row_id来计数，row_id是一个8字节的bigint unsigned，InnoDB在设计时只给row_id保留了6个字节的长度，这样row_id取值范围就是0到2^48 - 1，如果id的值达到了最大值，下一个值就从0开始继续循环递增，在代码中禁止指定主键id值插入。\n#新插入的id值会从10001开始，这是不对的，应该从1开始。\ncreate table booking( &#96;id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键id&#39;,......) engine &#x3D; InnoDB auto_increment &#x3D; 10000;\n\n#指定了id值插入，后续自增就会从该值开始+1，索引禁止指定id值插入。\ninsert into booking(id, book_sn) values(1234551121, &#39;N12121&#39;);\n\nNOT NULL属性根据业务含义，尽量将字段都添加上NOT NULL DEFAULT VALUE属性，如果列值存储了大量的NULL，会影响索引的稳定性。\nDEFAULT属性在创建表的时候，建议每个字段尽量都有默认值，禁止DEFAULT NULL，而是对字段类型填充响应的默认值。\nCOMMENT属性字段的备注要能明确该字段的作用，尤其是某些表示状态的字段，要显式的写出该字段所有可能的状态数值以及该数值的含义。\nTEXT类型不建议使用Text数据类型，一方面由于传输大量的数据包可能会超过max_allowed_packet设置导致程序报错，另一方面表上的DML操作都会变的很慢，建议采用es或者对象存储OSS来存储和检索。\n索引检查索引属性索引基数指的是被索引的列唯一值的个数，唯一值越多接近表的count(*)说明索引的选择率越高，通过索引扫描的行数就越少，性能就越高，例如主键id的选择率是100%，在MySQL中尽量所有的update都使用主键id去更新，因为id是聚集索引存储着整行数据，不需要回表，性能是最高的。\nmysql&gt; select count(*) from member_info;\n+----------+\n| count(*) |\n+----------+\n|   148416 |\n+----------+\n1 row in set (0.35 sec)\n\nmysql&gt; show index from member_base_info;\n+------------------+------------+----------------------------+--------------+-------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| Table            | Non_unique | Key_name                   | Seq_in_index | Column_name       | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |\n+------------------+------------+----------------------------+--------------+-------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n| member_info |          0 | PRIMARY                    |            1 | id                | A         |      131088 | NULL     | NULL   |      | BTREE      |         |               |\n| member_info |          0 | uk_member_id               |            1 | member_id         | A         |      131824 | NULL     | NULL   |      | BTREE      |         |               |\n| member_info |          1 | idx_create_time            |            1 | create_time       | A         |        6770 | NULL     | NULL   |      | BTREE      |         |               |\n+------------------+------------+----------------------------+--------------+-------------------+-----------+-------------+----------+--------+------+------------+---------+---------------+\n#Table： 表名\n#Non_unique ：是否为unique index，0-是，1-否。\n#Key_name：索引名称\n#Seq_in_index：索引中的顺序号，单列索引-都是1；复合索引-根据索引列的顺序从1开始递增。\n#Column_name：索引的列名\n#Collation：排序顺序，如果没有指定asc&#x2F;desc，默认都是升序ASC。\n#Cardinality：索引基数-索引列唯一值的个数。\n#sub_part：前缀索引的长度；例如index (member_name(10)，长度就是10。\n#Packed：索引的组织方式，默认是NULL。\n#Null：YES:索引列包含Null值；&#39;&#39;:索引不包含Null值。\n#Index_type：默认是BTREE，其他的值FULLTEXT，HASH，RTREE。\n#Comment：在索引列中没有被描述的信息，例如索引被禁用。\n#Index_comment：创建索引时的备注。\n\n前缀索引对于变长字符串类型varchar(m)，为了减少key_len，可以考虑创建前缀索引，但是前缀索引不能消除group by， order by带来排序开销。如果字段的实际最大值比m小很多，建议缩小字段长度。\nalter table member_info add index idx_member_name_part(member_name(10));\n\n复合索引顺序有很多人喜欢在创建复合索引的时候，总以为前导列一定是唯一值多的列，例如索引index idx_create_time_status(create_time, status)，这个索引往往是无法命中，因为扫描的IO次数太多，总体的cost的比全表扫描还大，CBO最终的选择是走full table scan。\nMySQL遵循的是索引最左匹配原则，对于复合索引，从左到右依次扫描索引列，到遇到第一个范围查询（&gt;&#x3D;, &gt;,&lt;, &lt;&#x3D;, between ….. and ….）就停止扫描，索引正确的索引顺序应该是index idx_status_create_time(status, create_time)。\nselect account_no, balance from accounts where status &#x3D; 1 and create_time between &#39;2020-09-01 00:00:00&#39; and &#39;2020-09-30 23:59:59&#39;;\n\n时间列索引对于默认字段created_at(create_time)、updated_at(update_time)这种默认就应该创建索引，这一般来说是默认的规则。\nSQL优化案例通过对慢查询的监控告警，经常发现一些SQL语句where过滤字段都有索引，但是由于SQL写法的问题导致索引失效，下面二个案例告诉大家如何通过SQL改写来查询。可以通过以下SQL来捞取最近5分钟的慢查询进行告警。\nselect CONCAT( &#39;# Time: &#39;, DATE_FORMAT(start_time, &#39;%y%m%d %H%i%s&#39;), &#39;\\n&#39;, &#39;# User@Host: &#39;, user_host, &#39;\\n&#39;, &#39;# Query_time: &#39;, TIME_TO_SEC(query_time),  &#39;  Lock_time: &#39;, TIME_TO_SEC(lock_time), &#39;  Rows_sent: &#39;, rows_sent, &#39;  Rows_examined: &#39;, rows_examined, &#39;\\n&#39;, sql_text, &#39;;&#39; ) FROM mysql.slow_log where start_time between current_timestamp and date_add(CURRENT_TIMESTAMP,INTERVAL -5 MINUTE);\n\n慢查询SQL| 2020-10-02 19:17:23 | w_mini_user[w_mini_user] @  [10.200.20.11] | 00:00:02   | 00:00:00  |         9 |        443117 | mini_user |              0 |         0 | 168387936 | select id,club_id,reason,status,type,created_time,invite_id,falg_admin,file_id from t_user_msg where 1 and (team_id in (3212) and app_id is not null) or (invite_id&#x3D;12395 or applicant_id&#x3D;12395) order by created_time desc limit 0,10; | 1219921665 |\n\n从慢查询slow_log可以看到，执行时间2s，扫描了443117行，只返回了9行，这是不合理的。\nSQL分析#原始SQL，频繁访问的接口，目前执行时间2s。\nselect id,team_id,reason,status,type,created_time,invite_id,falg_admin,file_id from t_user_msg where 1 and (team_id in (3212) and app_id is not null) or (invite_id&#x3D;12395 or app_id&#x3D;12395) order by created_time desc limit 0,10;\n\n#执行计划\n+----+-------------+--------------+-------+---------------------------------+------------+---------+------+------+-------------+\n| id | select_type | table        | type  | possible_keys                   | key        | key_len | ref  | rows | Extra       |\n+----+-------------+--------------+-------+---------------------------------+------------+---------+------+------+-------------+\n|  1 | SIMPLE      | t_user_msg | index | invite_id,app_id,team_id | created_time | 5       | NULL |   10 | Using where |\n+----+-------------+--------------+-------+---------------------------------+------------+---------+------+------+-------------+\n1 row in set (0.00 sec)\n\n从执行计划可以看到，表上有单列索引invite_id,app_id,team_id,created_time，走的是create_time的索引，而且type&#x3D;index索引全扫描，因为create_time没有出现在where条件后，只出现在order by后面，只能是type&#x3D;index，这也预示着表数据量越大该SQL越慢，我们期望是走三个单列索引invite_id，app_id，team_id，然后type&#x3D;index_merge操作。\n按照常规思路，对于OR条件拆分两部分，分别进行分析。\nselect id, ……. \nfrom t_user_msg \nwhere 1 and  **(team_id in (3212) and app_id is not null)** \norder by created_time desc limit 0,10;\n\n从执行计划看走的是team_id的索引，没有问题。\n| id | select_type | table        | type | possible_keys        | key     | key_len | ref   | rows | Extra                       |\n+----+-------------+--------------+------+----------------------+---------+---------+-------+------+-----------------------------+\n|  1 | SIMPLE      | t_user_msg | ref  | app_id,team_id | team_id | 8       | const |   30 | Using where; Using filesort |\n\n再看另外一个sql语句：\nselect id, ……. from t_user_msg where 1 and  **(invite_id&#x3D;12395 or app_id&#x3D;12395)** order by created_time desc limit 0,10;\n\n从执行计划上看，分别走的是invite_id,app_id的单列索引，同时做了index_merge合并操作，也没有问题。\n| id | select_type | table        | type        | possible_keys           | key                     | key_len | ref  | rows | Extra                                                             |\n+----+-------------+--------------+-------------+-------------------------+-------------------------+---------+------+------+-------------------------------------------------------------------+\n|  1 | SIMPLE      | t_user_msg | index_merge | invite_id,app_id | invite_id,app_id | 9,9     | NULL |    2 | Using union(invite_id,app_id); Using where; Using filesort |\n\n通过上面的分析，第一部分SQL走的执行计划走team_id索引没问题，第二部分SQL分别走invite_id,app_id索引并且index_merge也没问题，为什么两部分SQL进行OR关联之后走create_time的单列索引呢，不应该是三个单列索引的index_merge吗？\nindex_merge默认是在优化器选项是开启的，主要是将多个范围扫描的结果集合并成一个，可以通过变量查看。\nmysql &gt;select @@optimizer_switch;\n| index_merge&#x3D;on,index_merge_union&#x3D;on,index_merge_sort_union&#x3D;on,index_merge_intersection&#x3D;on,\n\n其他三个字段都传入的是具体的值，而且都走了相应的索引，只能怀疑app_id is not null这个条件影响了CBO对最终执行计划的选择，去掉这个条件来看执行计划，竟然走了三个单列索引且type&#x3D;index_merge，那下面只要搞定app_id is not null这个条件就OK了吧。\n| id | select_type | table        | type        | possible_keys                   | key                             | key_len | ref  | rows | Extra                                                                     |\n+----+-------------+--------------+-------------+---------------------------------+---------------------------------+---------+------+------+---------------------------------------------------------------------------+\n|  1 | SIMPLE      | t_user_msg | index_merge | invite_id,app_id,teadm_id | team_id,invite_id,app_id | 8,9,9   | NULL |   32 | Using union(team_id,invite_id,app_id); Using where; Using filesort |\n\nSQL改写通过上面分析得知，条件app_id is not null影响了CBO的选择，下面进行改造。\n改写优化1\n根据SQL开发规范改写，将OR改写成Union All方式即可，最终的SQL如下：\nselect id, ……. from (\nselect id, ……. from t_user_msg where **1 and (club_id in (5821) and applicant_id is not null)**\n        **union all** select id, ……. from t_user_msg where **1 and invitee_id&#x3D;&#39;146737&#39;**\n        **union all** select id, ……. from  t_user_msg where **1 and app_id&#x3D;&#39;146737&#39;**\n       ) as a order by created_time desc limit 0,10;\n\n一般情况下，Java代码和SQL是分开的，SQL是配置在xml文件中，根据业务需求，除了team_id是必填，其他两个都是可选的，所以这种改写虽然能提高SQL执行效率，但不适合这种业务场景。\n改写优化2\napp_id is not null 改写为**IFNULL(app_id, 0) &gt;0)**，最终的SQL为：\nselect id,team_id,reason,status,type,created_time,invite_id,falg_admin,file_id from t_user_msg where 1 and (team_id in (3212) and **IFNULL(app_id, 0) &gt;0)**) or (invite_id&#x3D;12395 or app_id&#x3D;12395) order by created_time desc limit 0,10;\n\n改写优化3\n将字段app_id bigint(20) DEFAULT NULL，变更为app_id bigint(20) NOT NULL DEFAULT 0，同时更新将app_id is null的时候全部更新成0，就可以将条件app_id is not null 转换为app_id &gt; 0，最终的SQL为：\nselect id,team_id,reason,status,type,created_at,invite_id,falg_admin,file_id \nfrom t_user_msg \nwhere 1 and (team_id in (3212) and **app_id &gt; 0)**) or (invite_id&#x3D;12395 or app_id&#x3D;12395) \norder by created_time desc limit 0,10;\n\n从执行计划看，两种改写优化方式都走三个单列索引，执行时间从2s降低至10ms，线上采用的是优化1的方式，如果一开始能遵循MySQL开发规范就就会避免问题的发生。\n总结上面介绍了SQL规范性检查，表结构检查，索引检查以及通过SQL改写来优化查询，在编写代码的过程，如果能提前做这些规范性检查，评估出自己认为理想的执行计划，然后通过explain解析出MySQL CBO的执行计划，两者做对比分析差异，弄清楚自己的选择和CBO的不同，不但能够编写高质量的SQL，同时也能清楚CBO的工作原理。\n\n文章持续更新，可以微信搜一搜「 三太子敖丙 」第一时间阅读，回复【资料】有我准备的一线大厂面试资料和简历模板，本文 GitHub github.com&#x2F;JavaFamily 已经收录，有大厂面试完整考点，欢迎Star。\n\n","categories":["数据分析"],"tags":["转载","SQL"]},{"title":"Python基础知识","url":"/2022/11/15/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"\n列表是有序的可变容器\n元组是有序的不可变容器\n字典是无序的可变容器–&gt;字典也被称作关联数组或者哈希表\n集合是无序且不可变类型容器\n\n\n\n\n元字符\n说明\n\n\n\n[\\b]\n回退（删除）一个字符\n\n\n\\f\n换页符\n\n\n\\n\n换行符\n\n\n\\r\n回车符\n\n\n\\t\n制表符\n\n\n\\v\n垂直制表符\n\n\n字符串方法\nfind–&gt;返回某个字符串位置\nreplace–&gt;替换某个字符串\nstrip–&gt;去除某个字符串\nsplit–&gt;以某个字符串前后拆分，不保留分隔符号，返回列表\npartition –&gt;以某个字符串前后拆分，保留分隔符号，返回元组\nindex–&gt;返回某个字符串的索引\nupper&amp;lower–&gt;转换大小写\njoin –&gt;用于在指定字符串中间穿插其他字符串\nformat–&gt;格式化输出\n\n\nappend–&gt;一次加一个\nextend–&gt;一次加多个\ninsert–&gt;指定索引位置插入\npop –&gt;指定索引位置删除\nremove–&gt;移除指定元素\ndel–&gt;删除整个对象\nclear–&gt;清空整个列表\nindex–&gt;返回列表元素的索引\ncount–&gt;统计列表元素出现次数\nin–&gt;\nsort–&gt;排序，可选reverse&#x3D;True反转\nreverse–&gt;反转列表\n\n元组方法\ncount\nindex\nin\n\n字典方法\nkeys()&#x2F;Values()–&gt;返回键&#x2F;值对象，需要使用list和tuple转换\nitems–&gt;返回键值元组\nupdate–&gt;有顺序更新，有方向更新，替换重复值\nsetdefault–&gt;选择性更新，原位置已有值返回原值，无值返回新值d.setdefault(‘A’, 5)\n\n集合方法\nadd –&gt;添加一个元素\nremove–&gt;移除一个元素\npop–&gt;随机删除一个元素\n交集运算符–&gt;&amp;    intersectionintersection_update\n并集运算符–&gt;|    union  update\n差集运算符–&gt;-    differencedifference_update\n补集运算符–&gt;^    symmetric_differencesymmetric_difference_update\n集合关系判断 –&gt;     issubset issupersetisdisjoint\n冻集合——不可变集合类型\n\n函数定义函数\ndef sum_1(a, b):\n    \"\"\"让输入的两个对象利用加号运算符进行相加\n    参数：\\n\n    a：函数输入的第一个对象\\n\n    b：函数输入的第二个对象\\n\n    return，返回a+b的结果\n    \"\"\"\n    c = a + b               \n    return(c)   \n\n形参和全局变量 # 定义时小括号中的参数，用来接收参数用的，称为 “形参”（形式参数），\n    # 而调用时小括号中的参数，用来传递给函数用的，称为 “实参”（实际参数） \ndef sum_1(a, b):            \n    c = a + b                \n    return(c)  \n    \ndef sum_2(b):\n    global a # 声明全局变量\n    a += b\n    return(a)    \n\n可变长参数def sum_2(*num):               # 此时*num就是一个可变长参数\n    r = 0\n    for i in num:              # 但可变长参数名仍然是num而非*num\n        r += i\n    return(r)\n\n类Class定义静态属性class Human:\n    '''人类'''\n    mam = True     \n定义动态属性\n\"\"\"\n__init__函数解释：      \n是一种特殊函数，也称为是构造函数，多用于带参数属性的类的创建过程；\nself是一个特殊的参数，相当于类本身的一种表示，相当于是C中的指针“this”，\n是init函数必须设置的第一个参数；\n\n类中定义的函数也需要传入self参数；\n这些函数可以通过外部调用方法的方式进行调用。\n\"\"\"\n\nclass Human:\n    '''人类'''\n    mam = True \n    def __init__(self, age = 0, gender = 'Unknow'):\n        self.age = age\n        self.gender = gender\n        \nzs = Human(10, 'M')       # 重新设置属性\n\nclass Human1:\n    '''人类'''\n    mam = True\n    @property             #属性私有化，防止被修改\n    def mam(self):\n        return True\n\"\"\"\nproperty，则可将方法转化为属性。\n因此，上述类的创建，相当于创建了一个属性mam和一个同名方法mam，并且将同名方法转化为了属性\n\"\"\"\n\n类的继承class Point:\n    def __init__(self, x = 0, y = 0):               \n        self.x = x\n        self.y = y\n    def dis(self, p):\n        return ((self.x - p.x) ** 2 + (self.y - p.y) ** 2) ** 0.5\n\nclass Point1(Point):     # 继承自Point类\n    def dis(self, p):\n        return (abs(self.x - p.x) + abs(self.y - p.y))\n\n二维到多维class Point2:\n    def __init__(self, *args):  # 定义一个可变长数组，并将其转化为列表对象\n        self.l = list(args)\n\nclass Point2:\n    def __init__(self, *args):               \n        self.l = list(args)\n    def dis(self, p):\n        t = []\n        for i in range(len(self.l)):\n            t.append((self.l[i] - p.l[i]) ** 2)\n        return sum(t) ** 0.5\n\n函数和方法的区别\n函数和方法的区别：方法是定义在类里面的函数！\n\n","categories":["数据分析"],"tags":["原创","Python"]},{"title":"NumPy生成自定义数组","url":"/2022/11/15/NumPy%E7%94%9F%E6%88%90%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84/","content":"特殊数组的创建方法\nnumpy.arange 生成数值范围\nnumpy.arange(start, stop, step, dtype)\nnumpy.linspace 生成等差数列\nnp.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)\n\nnumpy.logspace 生成等比数列\n\n\nnp.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)\n\nnp.zeros 全0数组\nnp.zeros(6)                      # 默认是浮点型\nnp.ones全1数组\nnp.ones((3, 2))                  # 三行两列\n随机数组：rand生成服从01分布的随机数\nnp.random.rand(5)                # 返回服从01分布的5个数\n\n随机数组：randn生成标准正态分布的随机数\nnp.random.randn(5) \n\n随机数组：normal生成元素是指定随机分布的数组\nnp.random.normal(4, 2, (3,3))   \n\narray([[ 5.53705005,  1.95477989,  3.07768639],       \n        [ 4.15457427,  3.69587242,  3.18715934],       \n        [ 5.46093734,  6.60888084, -0.55980278]])\n\n生成全数值相同的数组\nnp.full((2, 2), 3)\nnp.eye生成单位矩阵\nnp.eye(5)\n\narray([[1, 0, 0],\n       [0, 2, 0],\n       [0, 0, 3]])\n```       \n- np.diag生成对角矩阵\n```python\nnp.diag([1, 2, 3])\n\narray([[1, 0, 0],\n       [0, 2, 0],\n       [0, 0, 3]])\n```       \n- np.array按照某种形状生成ndarray\n```python\ne = [[2,1,3],[4,3,2]]\nnp.array(e)\n\narray([[2, 1, 3],\n       [4, 3, 2]])\n\nnp.ones_like(e)\nnp.zeros_like(e)\nnp.full_like(e,5)\n\n数组常用变形方法\nreshape方法：调整数组行列结构a1 = np.random.rand(2, 3)\na1\narray([[0.56262855, 0.73129141, 0.86289312],\n       [0.93186546, 0.93884182, 0.22485166]])\nflatten方法：将数组降为一维数组a1.flatten().shape\n(6,)\n.T方法：数组的转置a1\narray([[0.56262855, 0.73129141, 0.86289312],\n       [0.93186546, 0.93884182, 0.22485166]])\n\na1.T                    # 就类似于矩阵的转置\narray([[0.56262855, 0.93186546],\n       [0.73129141, 0.93884182],\n       [0.86289312, 0.22485166]])\n\n数组的拼接a1 = np.array([[1, 2], [3, 4]])\na2 = np.array([[5, 6], [7, 8]])\n\n(array([[1, 2],\n        [3, 4]]),\n array([[5, 6],\n        [7, 8]]))\n```        \n\n- vstack：纵向拼接，按列拼接，新增行，上下拼接\n\n```python\nnp.vstack([a1, a2])             # 需要输入一个序列\narray([[1, 2],\n       [3, 4],\n       [5, 6],\n       [7, 8]])\n\n\nhstack：横向拼接，按行拼接，新增列，左右拼接\n\nnp.hstack([a1, a2]) \narray([[1, 2, 5, 6],\n       [3, 4, 7, 8]])\n数组的切分当然，有拼接就有切分。接下来，简单看下数组的切分方法。拼接时关键字是stack，切分时关键字是split\na = np.arange(24).reshape(3,8)          # 创建3行8列的二维数组\na\narray([[ 0,  1,  2,  3,  4,  5,  6,  7],\n       [ 8,  9, 10, 11, 12, 13, 14, 15],\n       [16, 17, 18, 19, 20, 21, 22, 23]])\n\nhsplit：左右切分# 当第二个参数只输入一个数时，是进行等分\nnp.hsplit(a,2)\n\n[array([[ 0,  1,  2,  3],\n        [ 8,  9, 10, 11],\n        [16, 17, 18, 19]]),\n array([[ 4,  5,  6,  7],\n        [12, 13, 14, 15],\n        [20, 21, 22, 23]])]\n# 无法等分的情况会报错\nnp.hsplit(a,3)\n````\n```python\n# 当第二个参数输入一个序列时，则是根据列标进行切分\nnp.hsplit(a,(1,2,3))          # 第一列、第二列、第三列后进行切分\n\n[array([[ 0],\n        [ 8],\n        [16]]),\n array([[ 1],\n        [ 9],\n        [17]]),\n array([[ 2],\n        [10],\n        [18]]),\n array([[ 3,  4,  5,  6,  7],\n        [11, 12, 13, 14, 15],\n        [19, 20, 21, 22, 23]])]\n- vsplit：上下切分\n```python\nnp.vsplit(a,3)                # 三等分\n\n[array([[0, 1, 2, 3, 4, 5, 6, 7]]),\n array([[ 8,  9, 10, 11, 12, 13, 14, 15]]),\n array([[16, 17, 18, 19, 20, 21, 22, 23]])]\narray_split：通用切分方法# 均分\nnp.array_split(a, 2, axis=1)        # axis = 1，左右切分\n\n[array([[ 0,  1,  2,  3],\n        [ 8,  9, 10, 11],\n        [16, 17, 18, 19]]),\n array([[ 4,  5,  6,  7],\n        [12, 13, 14, 15],\n        [20, 21, 22, 23]])]\n# 根据列标进行切分\nnp.array_split(a, (1, ), axis=1)\n\n[array([[ 0],\n        [ 8],\n        [16]]),\n array([[ 1,  2,  3,  4,  5,  6,  7],\n        [ 9, 10, 11, 12, 13, 14, 15],\n        [17, 18, 19, 20, 21, 22, 23]])]\n# 均分\nnp.array_split(a, 3, axis=0)         # axis = 0，上下切分\n\n[array([[0, 1, 2, 3, 4, 5, 6, 7]]),\n array([[ 8,  9, 10, 11, 12, 13, 14, 15]]),\n array([[16, 17, 18, 19, 20, 21, 22, 23]])]\n# 根据行标进行切分\nnp.array_split(a, (1, ), axis=0)\n\n[array([[0, 1, 2, 3, 4, 5, 6, 7]]),\n array([[ 8,  9, 10, 11, 12, 13, 14, 15],\n        [16, 17, 18, 19, 20, 21, 22, 23]])]\n\n数组的算数运算\n\n\n数学运算函数\n描述\n\n\n\nnp.add(x1，x2 )\n按元素添加参数，等效于 x1 + x2\n\n\nnp.subtract(x1，x2)\n按元素方式减去参数，等效于x1 - x2\n\n\nnp.multiply(x1，x2)\n逐元素乘法参数，等效于x1 * x2\n\n\nnp.divide(x1，x2)\n逐元素除以参数，等效于x1 &#x2F; x2\n\n\nnp.exp(x)\n计算e的x次方。\n\n\nnp.exp2(x)\n计算2的x次方。\n\n\nnp.power(x1,x2)\n计算x1的x2次幂。\n\n\nnp.mod(x)\n返回输入数组中相应元素的除法余数.\n\n\nnp.log(x)\n自然对数，逐元素。\n\n\nnp.log2(x)\nx的基础2对数。\n\n\nnp.log10(x)\n以元素为单位返回输入数组的基数10的对数。\n\n\nnp.expm1(x)\n对数组中的所有元素计算exp（x） - 1\n\n\nnp.log1p(x)\n返回一个加自然对数的输入数组。\n\n\nnp.sqrt(x)\n按元素方式返回数组的正平方根。\n\n\nnp.square(x)\n返回输入的元素平方。\n\n\nnp.sin(x)\n三角正弦。\n\n\nnp.cos(x)\n元素余弦。\n\n\nnp.tan(x)\n逐元素计算切线。\n\n\nnp.round(x)\n四舍五入\n\n\nnp.floor(x)\n向下取整\n\n\nnp.ceil(x)\n向上取整\n\n\n数组的统计运算\n\n\n\nNumPy有很多有用的统计函数，用于从数组中给定的元素中查找最小，最大，百分标准差和方差等。\n\n\n\n常用统计函数：\n\n\n\n\n\n\n函数名称\nNaN安全版本\n描述\n\n\n\nnp.sum()\nnp.nansum()\n计算元素的和\n\n\nnp.min()\nnp.nanmin()\n找出最小值\n\n\nnp.max()\nnp.nanmax()\n找出最大值\n\n\nnp.prod()\nnp.nanprod()\n计算元素的积\n\n\nnp.ptp()\nN&#x2F;A\n计算元素的极差（最大值 - 最小值）\n\n\nnp.mean()\nnp.nanmean()\n计算元素的算术平均值\n\n\nnp.std()\nnp.nanstd()\n计算标准差\n\n\nnp.var()\nnp.nanvar()\n计算方差\n\n\nnp.percentile()\nnp.nanpercentile()\n计算百分位数\n\n\nnp.median()\nnp.nanmedian()\n计算中位数\n\n\nnp.average()\nN&#x2F;A\n返回数组的加权平均值\n\n\nnp.any()\nN&#x2F;A\n验证任何一个元素是否为真\n\n\nnp.all()\nN&#x2F;A\n验证所有元素是否为真\n\n\n数组的线性代数函数NumPy拥有numpy.linalg 模块，提供线性代数所需的所有功能。\n\nnp.dot() 返回两个数组的点积\nnp.vdot() 返回两个向量的点积\nnp.inner() 返回一维数组的向量内积\nnp.matmul() 返回两个数组的矩阵乘积\nnp.linalg.det() 计算输入矩阵的行列式\nnp.linalg.solve() 求解矩阵形式的线性方程的解\nnp.linalg.inv() 计算矩阵的逆\n\nPandas-DataFrame的创建df = pd.DataFrame(data=None, \n                  index=None, \n                  columns=None,\n                  dtype=None, \n                  copy=False\n                  )\n由Series创建DataFrames1 = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\ns2 = pd.Series([2, 3, 4], index=['b', 'c', 'd'])\ndf = pd.DataFrame([s1, s2])\n二维array创建DataFramel = [[1, 2, 3], [2, 3, 4]]\npd.DataFrame(a)\n利用字典创建DataFramed1 = &#123;'a':range(3),'b':range(3),'c':range(3)&#125;\npd.DataFrame(d1)\n在创建过程中，字典的Key会编程column名称，并且系统会自动生成index.\n","categories":["数据分析"],"tags":["原创","Python"]},{"title":"Python高级内容","url":"/2022/11/15/Python%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86/","content":"\n摘自廖雪峰老师python教程：原文链接：https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584参考链接：https://www.bilibili.com/video/BV1Vv411x7hj/?p=1&amp;vd_source=356ed72c41c85a755e40d7f41bb5e733\n\n可变参数和关键字参数可变参数参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n\n关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。\ndef person(name, age, **kw):\n    print('name:', name, 'age:', age, 'other:', kw)\n>>> person('Bob', 35, city='Beijing')\nname: Bob age: 35 other: &#123;'city': 'Beijing'&#125;\n>>> person('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125;\n\n递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，我们来计算阶乘n! &#x3D; 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：\nfact(n)=n!=1×2×3×⋅⋅⋅×(n−1)×n=(n−1)!×n=fact(n−1)×nfact(n)&#x3D;n!&#x3D;1\\times2\\times3\\times\\cdot\\cdot\\cdot\\times(n-1)\\times n&#x3D;(n-1)!\\times n&#x3D;fact(n-1)\\times n\n所以，fact(n)可以表示为n x fact(n-1)，只有n&#x3D;1时需要特殊处理。\n于是，fact(n)用递归的方式写出来就是：\ndef fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n列表生成式>>> [x * x for x in range(1, 11)]\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。\nfor循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：\n>>> [x * x for x in range(1, 11) if x % 2 == 0]\n[4, 16, 36, 64, 100]\n还可以使用两层循环，可以生成全排列：\n>>> [m + n for m in 'ABC' for n in 'XYZ']\n['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']\n三层和三层以上的循环就很少用到了。\n生成器只要把一个列表生成式的[]改成()，就创建了一个generator：\n>>> L = [x * x for x in range(10)]\n>>> L\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> g = (x * x for x in range(10))\n>>> g\n&lt;generator object &lt;genexpr> at 0x1022ef630>\n\n可以通过next()函数获得generator的下一个返回值：\n>>> next(g)\n0\n>>> next(g)\n1\n>>> next(g)\n4\n>>> next(g)\n9\n>>> next(g)\n16\n>>> next(g)\n25\n>>> next(g)\n36\n>>> next(g)\n49\n>>> next(g)\n64\n>>> next(g)\n81\n>>> next(g)\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nStopIteration\n\ngenerator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n当然，上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：\n>>> g = (x * x for x in range(10))\n>>> for n in g:\n...     print(n)\n... \n0\n1\n4\n9\n16\n25\n36\n49\n64\n81\n所以，我们创建了一个generator后，基本上永远不会调用next()，而是通过for循环来迭代它，并且不需要关心StopIteration的错误。\n迭代器我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n一类是集合数据类型，如list、tuple、dict、set、str等；\n一类是generator，包括生成器和带yield的generator function。\n这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。\n可以使用isinstance()判断一个对象是否是Iterable对象：\n>>> from collections.abc import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance(&#123;&#125;, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n\n而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。\n可以使用isinstance()判断一个对象是否是Iterator对象：\n>>> from collections.abc import Iterator\n>>> isinstance((x for x in range(10)), Iterator)\nTrue\n>>> isinstance([], Iterator)\nFalse\n>>> isinstance(&#123;&#125;, Iterator)\nFalse\n>>> isinstance('abc', Iterator)\nFalse\n\n生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。\n把list、dict、str等Iterable变成Iterator可以使用iter()函数：\n>>> isinstance(iter([]), Iterator)\nTrue\n>>> isinstance(iter('abc'), Iterator)\nTrue\n\n你可能会问，为什么list、dict、str等数据类型不是Iterator？\n这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。\nIterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。\n小结凡是可作用于for循环的对象都是Iterable类型；\n凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；\n集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。\nPython的for循环本质上就是通过不断调用next()函数实现的，例如：\nfor x in [1, 2, 3, 4, 5]:\n    pass\n\n实际上完全等价于：\n# 首先获得Iterator对象:\nit = iter([1, 2, 3, 4, 5])\n# 循环:\nwhile True:\n    try:\n        # 获得下一个值:\n        x = next(it)\n    except StopIteration:\n        # 遇到StopIteration就退出循环\n        break\n\n参考源码do_iter.py\n高级函数-mapPython内建了map()和reduce()函数。\n如果你读过Google的那篇大名鼎鼎的论文“MapReduce: Simplified Data Processing on Large Clusters”，你就能大概明白map&#x2F;reduce的概念。\n我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\n举例说明，比如我们有一个函数f(x)&#x3D;x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：\n            f(x) = x * x\n\n                  │\n                  │\n  ┌───┬───┬───┬───┼───┬───┬───┬───┐\n  │   │   │   │   │   │   │   │   │\n  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼\n\n[ 1   2   3   4   5   6   7   8   9 ]\n\n  │   │   │   │   │   │   │   │   │\n  │   │   │   │   │   │   │   │   │\n  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼\n\n[ 1   4   9  16  25  36  49  64  81 ]\n\n现在，我们用Python代码实现：\n>>> def f(x):\n...     return x * x\n...\n>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> list(r)\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nmap()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list。\n你可能会想，不需要map()函数，写一个循环，也可以计算出结果：\nL = []\nfor n in [1, 2, 3, 4, 5, 6, 7, 8, 9]:\n    L.append(f(n))\nprint(L)\n\n的确可以，但是，从上面的循环代码，能一眼看明白“把f(x)作用在list的每一个元素并把结果生成一个新的list”吗？\n所以，map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)&#x3D;x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：\n>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n['1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n只需要一行代码。\n再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n\n比方说对一个序列求和，就可以用reduce实现：\n>>> from functools import reduce\n>>> def add(x, y):\n...     return x + y\n...\n>>> reduce(add, [1, 3, 5, 7, 9])\n25\n\n当然求和运算可以直接用Python内建函数sum()，没必要动用reduce。\n但是如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场：\n>>> from functools import reduce\n>>> def fn(x, y):\n...     return x * 10 + y\n...\n>>> reduce(fn, [1, 3, 5, 7, 9])\n13579\n\n这个例子本身没多大用处，但是，如果考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：\n>>> from functools import reduce\n>>> def fn(x, y):\n...     return x * 10 + y\n...\n>>> def char2num(s):\n...     digits = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;\n...     return digits[s]\n...\n>>> reduce(fn, map(char2num, '13579'))\n13579\n\n整理成一个str2int的函数就是：\nfrom functools import reduce\n\nDIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;\n\ndef str2int(s):\n    def fn(x, y):\n        return x * 10 + y\n    def char2num(s):\n        return DIGITS[s]\n    return reduce(fn, map(char2num, s))\n\n还可以用lambda函数进一步简化成：\nfrom functools import reduce\n\nDIGITS = &#123;'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9&#125;\n\ndef char2num(s):\n    return DIGITS[s]\n\ndef str2int(s):\n    return reduce(lambda x, y: x * 10 + y, map(char2num, s))\n\n也就是说，假设Python没有提供int()函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！\nlambda函数的用法在后面介绍。\n练习利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]：\n# -*- coding: utf-8 -*-\n\n\n# 测试:\nL1 = ['adam', 'LISA', 'barT']\nL2 = list(map(normalize, L1))\nprint(L2)\n\n\nPython提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：\n# -*- coding: utf-8 -*-\nfrom functools import reduce\n\n\nprint('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))\nif prod([3, 5, 7, 9]) == 945:\n    print('测试成功!')\nelse:\n    print('测试失败!')\n\n\n利用map和reduce编写一个str2float函数，把字符串&#39;123.456&#39;转换成浮点数123.456：\n# -*- coding: utf-8 -*-\nfrom functools import reduce\n\ndef str2float(s):\n\n\nprint('str2float(\\'123.456\\') =', str2float('123.456'))\nif abs(str2float('123.456') - 123.456) &lt; 0.00001:\n    print('测试成功!')\nelse:\n    print('测试失败!')\n\n\n参考代码do_map.py\ndo_reduce.py\n返回函数函数作为返回值高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：\ndef calc_sum(*args):\n    ax = 0\n    for n in args:\n        ax = ax + n\n    return ax\n\n但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：\ndef lazy_sum(*args):\n    def sum():\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n    return sum\n\n当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：\n>>> f = lazy_sum(1, 3, 5, 7, 9)\n>>> f\n&lt;function lazy_sum.&lt;locals>.sum at 0x101c6ed90>\n\n调用函数f时，才真正计算求和的结果：\n>>> f()\n25\n\n在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\n请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：\n>>> f1 = lazy_sum(1, 3, 5, 7, 9)\n>>> f2 = lazy_sum(1, 3, 5, 7, 9)\n>>> f1==f2\nFalse\n\nf1()和f2()的调用结果互不影响。\n闭包注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。\n另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。\n你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n\n全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。\n返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：\ndef count():\n    def f(j):\n        def g():\n            return j*j\n        return g\n    fs = []\n    for i in range(1, 4):\n        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()\n    return fs\n\n再看看结果：\n>>> f1, f2, f3 = count()\n>>> f1()\n1\n>>> f2()\n4\n>>> f3()\n9\n\n缺点是代码较长，可利用lambda函数缩短代码。\nnonlocal使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常：\ndef inc():\n    x = 0\n    def fn():\n        # 仅读取x的值:\n        return x + 1\n    return fn\n\nf = inc()\nprint(f()) # 1\nprint(f()) # 1\n\n但是，如果对外层变量赋值，由于Python解释器会把x当作函数fn()的局部变量，它会报错：\n# -*- coding: utf-8 -*-\n\n\n原因是x作为局部变量并没有初始化，直接计算x+1是不行的。但我们其实是想引用inc()函数内部的x，所以需要在fn()函数内部加一个nonlocal x的声明。加上这个声明后，解释器把fn()的x看作外层函数的局部变量，它已经被初始化了，可以正确计算x+1。\n使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。\n练习利用闭包返回一个计数器函数，每次调用它返回递增整数：\n# -*- coding: utf-8 -*-\n\n\n# 测试:\ncounterA = createCounter()\nprint(counterA(), counterA(), counterA(), counterA(), counterA()) # 1 2 3 4 5\ncounterB = createCounter()\nif [counterB(), counterB(), counterB(), counterB()] == [1, 2, 3, 4]:\n    print('测试通过!')\nelse:\n    print('测试失败!')\n\n\n小结一个函数可以返回一个计算结果，也可以返回一个函数。\n返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。\n参考源码return_func.py\n装饰器\n原文链接：https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584参考链接：https://www.bilibili.com/video/BV1Vv411x7hj/?p=1&amp;vd_source=356ed72c41c85a755e40d7f41bb5e733\n\n由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。\n>>> def now():\n...     print('2015-3-25')\n...\n>>> f = now\n>>> f()\n2015-3-25\n\n函数对象有一个__name__属性（注意：是前后各两个下划线），可以拿到函数的名字：\n>>> now.__name__\n'now'\n>>> f.__name__\n'now'\n\n现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：\ndef log(func):\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\n观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：\n@log # 这个@log等于上面的外层log函数\ndef now():\n    print('2015-3-25')\n\n调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：\n>>> now()\ncall now():\n2015-3-25\n\n把@log放到now()函数的定义处，相当于执行了语句：\nnow = log(now)\n\n由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。\nwrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。\n如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n这个3层嵌套的decorator用法如下：\n@log('execute')\ndef now():\n    print('2015-3-25')\n\n执行结果如下：\n>>> now()\nexecute now():\n2015-3-25\n\n和两层嵌套的decorator相比，3层嵌套的效果是这样的：\n>>> now = log('execute')(now)\n\n我们来剖析上面的语句，首先执行log(&#39;execute&#39;)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。\n以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的&#39;now&#39;变成了&#39;wrapper&#39;：\n>>> now.__name__\n'wrapper'\n\n因为返回的那个wrapper()函数名字就是&#39;wrapper&#39;，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。\n不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：\nimport functools\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\n或者针对带参数的decorator：\nimport functools\n\ndef log(text):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kw):\n            print('%s %s():' % (text, func.__name__))\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\nimport functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。\n练习请设计一个decorator，它可作用于任何函数上，并打印该函数的执行时间：\n# -*- coding: utf-8 -*-\nimport time, functools\n\n\n# 测试\n@metric\ndef fast(x, y):\n    time.sleep(0.0012)\n    return x + y;\n\n@metric\ndef slow(x, y, z):\n    time.sleep(0.1234)\n    return x * y * z;\n\nf = fast(11, 22)\ns = slow(11, 22, 33)\nif f != 33:\n    print('测试失败!')\nelif s != 7986:\n    print('测试失败!')\n\n\n小结在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。\ndecorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。\n请编写一个decorator，能在函数调用的前后打印出&#39;begin call&#39;和&#39;end call&#39;的日志。\n再思考一下能否写出一个@log的decorator，使它既支持：\n@log\ndef f():\n    pass\n\n又支持：\n@log('execute')\ndef f():\n    pass\n\n参考源码decorator.py\n偏函数Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。\n在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：\nint()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换：\n>>> int('12345')\n12345\n\n但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：\n>>> int('12345', base=8)\n5349\n>>> int('12345', 16)\n74565\n\n假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去：\ndef int2(x, base=2):\n    return int(x, base)\n\n这样，我们转换二进制就非常方便了：\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n\nfunctools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：\n>>> import functools\n>>> int2 = functools.partial(int, base=2)\n>>> int2('1000000')\n64\n>>> int2('1010101')\n85\n\n所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。\n注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值：\n>>> int2('1000000', base=10)\n1000000\n\n最后，创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入：\nint2 = functools.partial(int, base=2)\n\n实际上固定了int()函数的关键字参数base，也就是：\nint2('10010')\n\n相当于：\nkw = &#123; 'base': 2 &#125;\nint('10010', **kw)\n\n当传入：\nmax2 = functools.partial(max, 10)\n\n实际上会把10作为*args的一部分自动加到左边，也就是：\nmax2(5, 6, 7)\n\n相当于：\nargs = (10, 5, 6, 7)\nmax(*args)\n\n结果为10。\n小结当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。\n参考源码do_partial.py\n类和实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n仍以Student类为例，在Python中，定义类是通过class关键字：\nclass Student(object):\n    pass\n\nclass后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。\n定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：\n>>> bart = Student()\n>>> bart\n&lt;__main__.Student object at 0x10a67a590>\n>>> Student\n&lt;class '__main__.Student'>\n\n可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。\n可以自由地给一个实例变量绑定属性，比如，给实例bart绑定一个name属性：\n>>> bart.name = 'Bart Simpson'\n>>> bart.name\n'Bart Simpson'\n\n由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，score等属性绑上去：\nclass Student(object):\n\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n注意：特殊方法“__init__”前后分别有两个下划线！！！\n注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。\n有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：\n>>> bart = Student('Bart Simpson', 59)\n>>> bart.name\n'Bart Simpson'\n>>> bart.score\n59\n\n和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。\n数据封装面向对象编程的一个重要特点就是数据封装。在上面的Student类中，每个实例就拥有各自的name和score这些数据。我们可以通过函数来访问这些数据，比如打印一个学生的成绩：\n>>> def print_score(std):\n...     print('%s: %s' % (std.name, std.score))\n...\n>>> print_score(bart)\nBart Simpson: 59\n\n但是，既然Student实例本身就拥有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在Student类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和Student类本身是关联起来的，我们称之为类的方法：\nclass Student(object):\n\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n\n    def print_score(self):\n        print('%s: %s' % (self.name, self.score))\n\n要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入：\n>>> bart.print_score()\nBart Simpson: 59\n\n这样一来，我们从外部看Student类，就只需要知道，创建实例需要给出name和score，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。\n封装的另一个好处是可以给Student类增加新的方法，比如get_grade：\nclass Student(object):\n    ...\n\n    def get_grade(self):\n        if self.score >= 90:\n            return 'A'\n        elif self.score >= 60:\n            return 'B'\n        else:\n            return 'C'\n\n同样的，get_grade方法可以直接在实例变量上调用，不需要知道内部实现细节：\n# -*- coding: utf-8 -*-\n\n\nlisa = Student('Lisa', 99)\nbart = Student('Bart', 59)\nprint(lisa.name, lisa.get_grade())\nprint(bart.name, bart.get_grade())\n\n\n小结类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；\n方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；\n通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。\n和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：\n>>> bart = Student('Bart Simpson', 59)\n>>> lisa = Student('Lisa Simpson', 87)\n>>> bart.age = 8\n>>> bart.age\n8\n>>> lisa.age\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nAttributeError: 'Student' object has no attribute 'age'\n\n参考源码student.py\n访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。\n但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性：\n>>> bart = Student('Bart Simpson', 59)\n>>> bart.score\n59\n>>> bart.score = 99\n>>> bart.score\n99\n\n如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改：\nclass Student(object):\n\n    def __init__(self, name, score):\n        self.__name = name\n        self.__score = score\n\n    def print_score(self):\n        print('%s: %s' % (self.__name, self.__score))\n\n改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了：\n>>> bart = Student('Bart Simpson', 59)\n>>> bart.__name\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nAttributeError: 'Student' object has no attribute '__name'\n\n这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。\n但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法：\nclass Student(object):\n    ...\n\n    def get_name(self):\n        return self.__name\n\n    def get_score(self):\n        return self.__score\n\n如果又要允许外部代码修改score怎么办？可以再给Student类增加set_score方法：\nclass Student(object):\n    ...\n\n    def set_score(self, score):\n        self.__score = score\n\n你也许会问，原先那种直接通过bart.score = 99也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：\nclass Student(object):\n    ...\n\n    def set_score(self, score):\n        if 0 &lt;= score &lt;= 100:\n            self.__score = score\n        else:\n            raise ValueError('bad score')\n\n需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。\n有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。\n双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：\n>>> bart._Student__name\n'Bart Simpson'\n\n但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。\n总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。\n最后注意下面的这种_错误写法_：\n>>> bart = Student('Bart Simpson', 59)\n>>> bart.get_name()\n'Bart Simpson'\n>>> bart.__name = 'New Name' # 设置__name变量！\n>>> bart.__name\n'New Name'\n\n表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量_不是_一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量。不信试试：\n>>> bart.get_name() # get_name()内部返回self.__name\n'Bart Simpson'\n\n练习请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性：\n# -*- coding: utf-8 -*-\n\n# 测试:\nbart = Student('Bart', 'male')\nif bart.get_gender() != 'male':\n    print('测试失败!')\nelse:\n    bart.set_gender('female')\n    if bart.get_gender() != 'female':\n        print('测试失败!')\n    else:\n        print('测试成功!')\n\n\n参考源码protected_student.py\n继承和多态在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。\n比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：\nclass Animal(object):\n    def run(self):\n        print('Animal is running...')\n\n当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：\nclass Dog(Animal):\n    pass\n\nclass Cat(Animal):\n    pass\n\n对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。\n继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：\ndog = Dog()\ndog.run()\n\ncat = Cat()\ncat.run()\n\n运行结果如下：\nAnimal is running...\nAnimal is running...\n\n当然，也可以对子类增加一些方法，比如Dog类：\nclass Dog(Animal):\n\n    def run(self):\n        print('Dog is running...')\n\n    def eat(self):\n        print('Eating meat...')\n\n继承的第二个好处需要我们对代码做一点改进。你看到了，无论是Dog还是Cat，它们run()的时候，显示的都是Animal is running...，符合逻辑的做法是分别显示Dog is running...和Cat is running...，因此，对Dog和Cat类改进如下：\nclass Dog(Animal):\n\n    def run(self):\n        print('Dog is running...')\n\nclass Cat(Animal):\n\n    def run(self):\n        print('Cat is running...')\n\n再次运行，结果如下：\nDog is running...\nCat is running...\n\n当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。\n要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：\na = list() # a是list类型\nb = Animal() # b是Animal类型\nc = Dog() # c是Dog类型\n\n判断一个变量是否是某个类型可以用isinstance()判断：\n>>> isinstance(a, list)\nTrue\n>>> isinstance(b, Animal)\nTrue\n>>> isinstance(c, Dog)\nTrue\n\n看来a、b、c确实对应着list、Animal、Dog这3种类型。\n但是等等，试试：\n>>> isinstance(c, Animal)\nTrue\n\n看来c不仅仅是Dog，c还是Animal！\n不过仔细想想，这是有道理的，因为Dog是从Animal继承下来的，当我们创建了一个Dog的实例c时，我们认为c的数据类型是Dog没错，但c同时也是Animal也没错，Dog本来就是Animal的一种！\n所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：\n>>> b = Animal()\n>>> isinstance(b, Dog)\nFalse\n\nDog可以看成Animal，但Animal不可以看成Dog。\n要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：\ndef run_twice(animal):\n    animal.run()\n    animal.run()\n\n当我们传入Animal的实例时，run_twice()就打印出：\n>>> run_twice(Animal())\nAnimal is running...\nAnimal is running...\n\n当我们传入Dog的实例时，run_twice()就打印出：\n>>> run_twice(Dog())\nDog is running...\nDog is running...\n\n当我们传入Cat的实例时，run_twice()就打印出：\n>>> run_twice(Cat())\nCat is running...\nCat is running...\n\n看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：\nclass Tortoise(Animal):\n    def run(self):\n        print('Tortoise is running slowly...')\n\n当我们调用run_twice()时，传入Tortoise的实例：\n>>> run_twice(Tortoise())\nTortoise is running slowly...\nTortoise is running slowly...\n\n你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。\n多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：\n对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：\n对扩展开放：允许新增Animal子类；\n对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。\n继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：\n                ┌───────────────┐\n                │    object     │\n                └───────────────┘\n                        │\n           ┌────────────┴────────────┐\n           │                         │\n           ▼                         ▼\n    ┌─────────────┐           ┌─────────────┐\n    │   Animal    │           │    Plant    │\n    └─────────────┘           └─────────────┘\n           │                         │\n     ┌─────┴──────┐            ┌─────┴──────┐\n     │            │            │            │\n     ▼            ▼            ▼            ▼\n┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐\n│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │\n└─────────┘  └─────────┘  └─────────┘  └─────────┘\n\n静态语言 vs 动态语言对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。\n对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：\nclass Timer(object):\n    def run(self):\n        print('Start...')\n\n这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。\nPython的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。\n小结继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。\n动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。\n参考源码animals.py\n使用__slots__  &#x3D; (‘name’, ‘age’) # 用tuple定义允许绑定的属性名称正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。先定义class：\nclass Student(object):\n    pass\n\n然后，尝试给实例绑定一个属性：\n>>> s = Student()\n>>> s.name = 'Michael' # 动态给实例绑定一个属性\n>>> print(s.name)\nMichael\n\n还可以尝试给实例绑定一个方法：\n>>> def set_age(self, age): # 定义一个函数作为实例方法\n...     self.age = age\n...\n>>> from types import MethodType\n>>> s.set_age = MethodType(set_age, s) # 给实例绑定一个方法\n>>> s.set_age(25) # 调用实例方法\n>>> s.age # 测试结果\n25\n\n但是，给一个实例绑定的方法，对另一个实例是不起作用的：\n>>> s2 = Student() # 创建新的实例\n>>> s2.set_age(25) # 尝试调用方法\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nAttributeError: 'Student' object has no attribute 'set_age'\n\n为了给所有实例都绑定方法，可以给class绑定方法：\n>>> def set_score(self, score):\n...     self.score = score\n...\n>>> Student.set_score = set_score\n\n给class绑定方法后，所有实例均可调用：\n>>> s.set_score(100)\n>>> s.score\n100\n>>> s2.set_score(99)\n>>> s2.score\n99\n\n通常情况下，上面的set_score方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。\n使用__slots__但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。\n为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：\nclass Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n\n然后，我们试试：\n>>> s = Student() # 创建新的实例\n>>> s.name = 'Michael' # 绑定属性'name'\n>>> s.age = 25 # 绑定属性'age'\n>>> s.score = 99 # 绑定属性'score'\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nAttributeError: 'Student' object has no attribute 'score'\n\n由于&#39;score&#39;没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。\n使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：\n>>> class GraduateStudent(Student):\n...     pass\n...\n>>> g = GraduateStudent()\n>>> g.score = 9999\n\n除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。\n参考源码use_slots.py\n使用@property在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：\ns = Student()\ns.score = 9999\n\n这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：\nclass Student(object):\n\n    def get_score(self):\n         return self._score\n\n    def set_score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value &lt; 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n\n现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：\n>>> s = Student()\n>>> s.set_score(60) # ok!\n>>> s.get_score()\n60\n>>> s.set_score(9999)\nTraceback (most recent call last):\n  ...\nValueError: score must between 0 ~ 100!\n\n但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。\n有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！\n\n还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：\n\nPython内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：\n\nimport functools\n\ndef log(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kw):\n        print('call %s():' % func.__name__)\n        return func(*args, **kw)\n    return wrapper\n\nclass Student(object):\n\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value &lt; 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n\n@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：\n>>> s = Student()\n>>> s.score = 60 # OK，实际转化为s.set_score(60)\n>>> s.score # OK，实际转化为s.get_score()\n60\n>>> s.score = 9999\nTraceback (most recent call last):\n  ...\nValueError: score must between 0 ~ 100!\n\n注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。\n还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：\nclass Student(object):\n\n    @property\n    def birth(self):\n        return self._birth\n\n    @birth.setter\n    def birth(self, value):\n        self._birth = value\n\n    @property\n    def age(self):\n        return 2015 - self._birth\n\n上面的birth是可读写属性，而age就是一个_只读_属性，因为age可以根据birth和当前时间计算出来。\n要特别注意：属性的方法名不要和实例变量重名。例如，以下的代码是错误的：\nclass Student(object):\n\n    # 方法名称和实例变量均为birth:\n    @property\n    def birth(self):\n        return self.birth\n\n这是因为调用s.birth时，首先转换为方法调用，在执行return self.birth时，又视为访问self的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错RecursionError。\n小结@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。\n练习请利用@property给一个Screen对象加上width和height属性，以及一个只读属性resolution：\n# -*- coding: utf-8 -*-\n\n\n# 测试:\ns = Screen()\ns.width = 1024\ns.height = 768\nprint('resolution =', s.resolution)\nif s.resolution == 786432:\n    print('测试通过!')\nelse:\n    print('测试失败!')\n\n\n参考源码use_property.py\n定制类 __xxx__看到类似__slots__这种形如__xxx__的变量或者函数名就要注意，这些在Python中是有特殊用途的。\n__slots__我们已经知道怎么用了，__len__()方法我们也知道是为了能让class作用于len()函数。\n除此之外，Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。\n__str__我们先定义一个Student类，打印一个实例：\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...\n>>> print(Student('Michael'))\n&lt;__main__.Student object at 0x109afb190>\n\n打印出一堆&lt;__main__.Student object at 0x109afb190&gt;，不好看。\n怎么才能打印得好看呢？只需要定义好__str__()方法，返回一个好看的字符串就可以了：\n>>> class Student(object):\n...     def __init__(self, name):\n...         self.name = name\n...     def __str__(self):\n...         return 'Student object (name: %s)' % self.name\n...\n>>> print(Student('Michael'))\nStudent object (name: Michael)\n\n这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。\n但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：\n>>> s = Student('Michael')\n>>> s\n&lt;__main__.Student object at 0x109afb310>\n\n这是因为直接显示变量调用的不是__str__()，而是__repr__()，两者的区别是__str__()返回用户看到的字符串，而__repr__()返回程序开发者看到的字符串，也就是说，__repr__()是为调试服务的。\n解决办法是再定义一个__repr__()。但是通常__str__()和__repr__()代码都是一样的，所以，有个偷懒的写法：\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return 'Student object (name=%s)' % self.name\n    __repr__ = __str__\n\n__iter__如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的__next__()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。\n我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1 # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self # 实例本身就是迭代对象，故返回自己\n\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b # 计算下一个值\n        if self.a > 100000: # 退出循环的条件\n            raise StopIteration()\n        return self.a # 返回下一个值\n\n现在，试试把Fib实例作用于for循环：\n>>> for n in Fib():\n...     print(n)\n...\n1\n1\n2\n3\n5\n...\n46368\n75025\n\n__getitem__Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：\n>>> Fib()[5]\nTraceback (most recent call last):\n  File \"&lt;stdin>\", line 1, in &lt;module>\nTypeError: 'Fib' object does not support indexing\n\n要表现得像list那样按照下标取出元素，需要实现__getitem__()方法：\nclass Fib(object):\n    def __getitem__(self, n):\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n\n现在，就可以按下标访问数列的任意一项了：\n>>> f = Fib()\n>>> f[0]\n1\n>>> f[1]\n1\n>>> f[2]\n2\n>>> f[3]\n3\n>>> f[10]\n89\n>>> f[100]\n573147844013817084101\n\n但是list有个神奇的切片方法：\n>>> list(range(100))[5:10]\n[5, 6, 7, 8, 9]\n\n对于Fib却报错。原因是__getitem__()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int): # n是索引\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice): # n是切片\n            start = n.start\n            stop = n.stop\n            if start is None:\n                start = 0\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n\n现在试试Fib的切片：\n>>> f = Fib()\n>>> f[0:5]\n[1, 1, 2, 3, 5]\n>>> f[:10]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\n但是没有对step参数作处理：\n>>> f[:10:2]\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n\n也没有对负数作处理，所以，要正确实现一个__getitem__()还是有很多工作要做的。\n此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。\n__getattr__正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义Student类：\nclass Student(object):\n    \n    def __init__(self):\n        self.name = 'Michael'\n\n调用name属性，没问题，但是，调用不存在的score属性，就有问题了：\n>>> s = Student()\n>>> print(s.name)\nMichael\n>>> print(s.score)\nTraceback (most recent call last):\n  ...\nAttributeError: 'Student' object has no attribute 'score'\n\n错误信息很清楚地告诉我们，没有找到score这个attribute。\n要避免这个错误，除了可以加上一个score属性外，Python还有另一个机制，那就是写一个__getattr__()方法，动态返回一个属性。修改如下：\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\n\n当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, &#39;score&#39;)来尝试获得属性，这样，我们就有机会返回score的值：\n>>> s = Student()\n>>> s.name\n'Michael'\n>>> s.score\n99\n\n返回函数也是完全可以的：\nclass Student(object):\n\n    def __getattr__(self, attr):\n        if attr=='age':\n            return lambda: 25\n\n只是调用方式要变为：\n>>> s.age()\n25\n\n注意，只有在没有找到属性的情况下，才调用__getattr__，已有的属性，比如name，不会在__getattr__中查找。\n此外，注意到任意调用如s.abc都会返回None，这是因为我们定义的__getattr__默认返回就是None。要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误：\nclass Student(object):\n\n    def __getattr__(self, attr):\n        if attr=='age':\n            return lambda: 25\n        raise AttributeError('\\'Student\\' object has no attribute \\'%s\\'' % attr)\n\n这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。\n这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。\n举个例子：\n现在很多网站都搞REST API，比如新浪微博、豆瓣啥的，调用API的URL类似：\n\nhttp://api.server/user/friends\nhttp://api.server/user/timeline/list\n\n如果要写SDK，给每个URL对应的API都写一个方法，那得累死，而且，API一旦改动，SDK也要改。\n利用完全动态的__getattr__，我们可以写出一个链式调用：\nclass Chain(object):\n\n    def __init__(self, path=''):\n        self._path = path\n\n    def __getattr__(self, path):\n        return Chain('%s/%s' % (self._path, path))\n\n    def __str__(self):\n        return self._path\n\n    __repr__ = __str__\n\n试试：\n>>> Chain().status.user.timeline.list\n'/status/user/timeline/list'\n\n这样，无论API怎么变，SDK都可以根据URL实现完全动态的调用，而且，不随API的增加而改变！\n还有些REST API会把参数放到URL中，比如GitHub的API：\nGET /users/:user/repos\n\n调用时，需要把:user替换为实际用户名。如果我们能写出这样的链式调用：\nChain().users('michael').repos\n\n就可以非常方便地调用API了。有兴趣的童鞋可以试试写出来。\n__call__一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用instance.method()来调用。能不能直接在实例本身上调用呢？在Python中，答案是肯定的。\n任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\n\n调用方式如下：\n>>> s = Student('Michael')\n>>> s() # self参数不要传入\nMy name is Michael.\n\n__call__()还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。\n如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。\n那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call__()的类实例：\n>>> callable(Student())\nTrue\n>>> callable(max)\nTrue\n>>> callable([1, 2, 3])\nFalse\n>>> callable(None)\nFalse\n>>> callable('str')\nFalse\n\n通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。\n小结Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。\n本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考Python的官方文档。\n参考源码special_str.py\nspecial_iter.py\nspecial_getitem.py\nspecial_getattr.py\nspecial_call.py\n","categories":["数据分析"],"tags":["转载","Python"]},{"title":"TCP协议入门-阮一峰","url":"/2022/11/21/TCP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8-%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2017/06/tcp-protocol.htmlTCP 是互联网核心协议之一，本文介绍它的基础知识。\n\n\n一、TCP 协议的作用互联网由一整套协议构成。TCP 只是其中的一层，有着自己的分工。\n\n（图片说明：TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议。）\n最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。\n\n（图片说明：以太网协议解决了局域网的点对点通信。）\n但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。\n\n（图片说明：IP 协议可以连接多个局域网。）\nIP 协议定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。\n\n（图片说明：路由器就是基于 IP 协议。局域网之间要靠路由器连接。）\n路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，……通过这套”指路牌”，实现了数据包的转发。\n\n（图片说明：本机的路由表注明了不同 IP 目的地的数据包，要发送到哪一个网口（interface）。）\nIP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。\n简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。\n二、TCP 数据包的大小以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）。\nIP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节。\n\n（图片说明：IP 数据包在以太网数据包里面，TCP 数据包在 IP 数据包里面。）\nTCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 &#x3D; 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。\n因此，一条1500字节的信息需要两个 TCP 数据包。HTTP&#x2F;2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。\n\n（图片说明：以太网数据包的负载是1500字节，TCP 数据包的负载在1400字节左右。）\n三、TCP 数据包的编号（SEQ）一个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。\n发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。\n第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。\n\n（图片说明：当前包的编号是45943，下一个数据包的编号是46183，由此可知，这个包的负载是240字节。）\n四、TCP 数据包的组装收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。\n对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。\nTCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息Content-Length，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。\n操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。\n\n（图片说明：系统根据 TCP 数据包里面的端口，将组装好的数据转交给相应的应用程序。上图中，21端口是 FTP 服务器，25端口是 SMTP 服务，80端口是 Web 服务器。）\n应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的Content-Length字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。\n五、慢启动和 ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。\n最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。\nTCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。\nLinux 内核里面设定了（常量TCP_INIT_CWND），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。\n默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。\nACK 携带两个信息。\n\n\n期待要收到下一个数据包的编号\n接收方的接收窗口的剩余容量\n\n\n发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。\n\n（图片说明：每个 ACK 都带有下一个数据包的编号，以及接收窗口的剩余容量。双方都会发送 ACK。）\n注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。\n\n（图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 &#x3D; 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。）\n即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。\n六、数据包的遗失处理TCP 协议可以保证数据通信的完整性，这是怎么做到的？\n前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。\n举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。\n如果发送方发现收到三个连续的重复 ACK，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。\n\n（图片说明：Host B 没有收到100号数据包，会连续发出相同的 ACK，触发 Host A 重发100号数据包。）\n七、参考链接\nNetwork protocols for programmers who know at least one programming language\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"SSL/TLS协议运行机制的概述-阮一峰","url":"/2022/11/23/TLS%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html\n\n互联网的通信安全，建立在SSL&#x2F;TLS协议之上。\n本文简要介绍SSL&#x2F;TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅RFC文档。\n\n一、作用\n不使用SSL&#x2F;TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。\n\n（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。\n（2） 篡改风险（tampering）：第三方可以修改通信内容。\n（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。\n\nSSL&#x2F;TLS协议是为了解决这三大风险而设计的，希望达到：\n\n（1） 所有信息都是加密传播，第三方无法窃听。\n（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。\n（3） 配备身份证书，防止身份被冒充。\n\n互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL&#x2F;TLS协议变得异常复杂。\n二、历史\n互联网加密通信协议的历史，几乎与互联网一样长。\n\n1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。\n1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。\n1996年，SSL 3.0版问世，得到大规模应用。\n1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。\n2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。\n\n目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。\nTLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。\n三、基本的运行过程\nSSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n但是，这里有两个问题。\n（1）如何保证公钥不被篡改？\n\n解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。\n\n（2）公钥加密计算量太大，如何减少耗用的时间？\n\n解决方法：每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。\n\n因此，SSL&#x2F;TLS协议的基本过程是这样的：\n\n（1） 客户端向服务器端索要并验证公钥。\n（2） 双方协商生成”对话密钥”。\n（3） 双方采用”对话密钥”进行加密通信。\n\n上面过程的前两步，又称为”握手阶段”（handshake）。\n四、握手阶段的详细过程\n\n“握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。\n4.1 客户端发出请求（ClientHello）\n首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。\n在这一步，客户端主要向服务器提供以下信息。\n\n（1） 支持的协议版本，比如TLS 1.0版。\n（2） 一个客户端生成的随机数，稍后用于生成”对话密钥”。\n（3） 支持的加密方法，比如RSA公钥加密。\n（4） 支持的压缩方法。\n\n这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。\n对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。\n4.2 服务器回应（SeverHello）\n服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。\n\n（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。\n（2） 一个服务器生成的随机数，稍后用于生成”对话密钥”。\n（3） 确认使用的加密方法，比如RSA公钥加密。\n（4） 服务器证书。\n\n除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。\n4.3 客户端回应\n客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。\n如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。\n\n（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。\n（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。\n\n上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。\n至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好：\n\n“不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。\n对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。\npre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。”\n\n此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。\n4.4 服务器的最后回应\n服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。\n\n（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。\n\n至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。\n\n五、参考链接\n\nMicroSoft TechNet, SSL&#x2F;TLS in Detail\nJeff Moser, The First Few Milliseconds of an HTTPS Connection\nWikipedia, Transport Layer Security\nStackExchange, How does SSL work?\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"WebSocket 教程-阮一峰","url":"/2022/11/21/WebSocket%20%E6%95%99%E7%A8%8B-%E9%98%AE%E4%B8%80%E5%B3%B0/","content":"\n原文链接：https://www.ruanyifeng.com/blog/2017/05/websocket.html\n\nWebSocket 是一种网络通信协议，很多高级功能都需要它。\n本文介绍 WebSocket 协议的使用方法。\n\n一、为什么需要 WebSocket？初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？\n答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。\n举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。\n\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。\n轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。\n二、简介WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。\n它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。\n\n其他特点包括：\n（1）建立在 TCP 协议之上，服务器端的实现比较容易。\n（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。\n（3）数据格式比较轻量，性能开销小，通信高效。\n（4）可以发送文本，也可以发送二进制数据。\n（5）没有同源限制，客户端可以与任意服务器通信。\n（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n\n\nws:&#x2F;&#x2F;example.com:80&#x2F;some&#x2F;path\n\n\n三、客户端的简单示例WebSocket 的用法相当简单。\n下面是一个网页脚本的例子（点击这里看运行结果），基本上一眼就能明白。\n\n\nvar ws &#x3D; new WebSocket(&quot;wss:&#x2F;&#x2F;echo.websocket.org&quot;);\n\nws.onopen &#x3D; function(evt) &#123; \n  console.log(&quot;Connection open ...&quot;); \n  ws.send(&quot;Hello WebSockets!&quot;);\n&#125;;\n\nws.onmessage &#x3D; function(evt) &#123;\n  console.log( &quot;Received Message: &quot; + evt.data);\n  ws.close();\n&#125;;\n\nws.onclose &#x3D; function(evt) &#123;\n  console.log(&quot;Connection closed.&quot;);\n&#125;;      \n\n四、客户端的 APIWebSocket 客户端的 API 如下。\n4.1 WebSocket 构造函数WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。\n\n\nvar ws &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;);\n\n执行上面语句之后，客户端就会与服务器进行连接。\n实例对象的所有属性和方法清单，参见这里。\n4.2 webSocket.readyStatereadyState属性返回实例对象的当前状态，共有四种。\n\n\nCONNECTING：值为0，表示正在连接。\nOPEN：值为1，表示连接成功，可以通信了。\nCLOSING：值为2，表示连接正在关闭。\nCLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n\n\n下面是一个示例。\n\n\nswitch (ws.readyState) &#123;\n  case WebSocket.CONNECTING:\n    &#x2F;&#x2F; do something\n    break;\n  case WebSocket.OPEN:\n    &#x2F;&#x2F; do something\n    break;\n  case WebSocket.CLOSING:\n    &#x2F;&#x2F; do something\n    break;\n  case WebSocket.CLOSED:\n    &#x2F;&#x2F; do something\n    break;\n  default:\n    &#x2F;&#x2F; this never happens\n    break;\n&#125;\n\n4.3 webSocket.onopen实例对象的onopen属性，用于指定连接成功后的回调函数。\n\n\nws.onopen &#x3D; function () &#123;\n  ws.send(&#39;Hello Server!&#39;);\n&#125;\n\n如果要指定多个回调函数，可以使用addEventListener方法。\n\n\nws.addEventListener(&#39;open&#39;, function (event) &#123;\n  ws.send(&#39;Hello Server!&#39;);\n&#125;);\n\n4.4 webSocket.onclose实例对象的onclose属性，用于指定连接关闭后的回调函数。\n\n\nws.onclose &#x3D; function(event) &#123;\n  var code &#x3D; event.code;\n  var reason &#x3D; event.reason;\n  var wasClean &#x3D; event.wasClean;\n  &#x2F;&#x2F; handle close event\n&#125;;\n\nws.addEventListener(&quot;close&quot;, function(event) &#123;\n  var code &#x3D; event.code;\n  var reason &#x3D; event.reason;\n  var wasClean &#x3D; event.wasClean;\n  &#x2F;&#x2F; handle close event\n&#125;);\n\n4.5 webSocket.onmessage实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。\n\n\nws.onmessage &#x3D; function(event) &#123;\n  var data &#x3D; event.data;\n  &#x2F;&#x2F; 处理数据\n&#125;;\n\nws.addEventListener(&quot;message&quot;, function(event) &#123;\n  var data &#x3D; event.data;\n  &#x2F;&#x2F; 处理数据\n&#125;);\n\n注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。\n\n\nws.onmessage &#x3D; function(event)&#123;\n  if(typeof event.data &#x3D;&#x3D;&#x3D; String) &#123;\n    console.log(&quot;Received data string&quot;);\n  &#125;\n\n  if(event.data instanceof ArrayBuffer)&#123;\n    var buffer &#x3D; event.data;\n    console.log(&quot;Received arraybuffer&quot;);\n  &#125;\n&#125;\n\n除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。\n\n\n&#x2F;&#x2F; 收到的是 blob 数据\nws.binaryType &#x3D; &quot;blob&quot;;\nws.onmessage &#x3D; function(e) &#123;\n  console.log(e.data.size);\n&#125;;\n\n&#x2F;&#x2F; 收到的是 ArrayBuffer 数据\nws.binaryType &#x3D; &quot;arraybuffer&quot;;\nws.onmessage &#x3D; function(e) &#123;\n  console.log(e.data.byteLength);\n&#125;;\n\n4.6 webSocket.send()实例对象的send()方法用于向服务器发送数据。\n发送文本的例子。\n\n\nws.send(&#39;your message&#39;);\n\n发送 Blob 对象的例子。\n\n\nvar file &#x3D; document\n  .querySelector(&#39;input[type&#x3D;&quot;file&quot;]&#39;)\n  .files[0];\nws.send(file);\n\n发送 ArrayBuffer 对象的例子。\n\n\n&#x2F;&#x2F; Sending canvas ImageData as ArrayBuffer\nvar img &#x3D; canvas_context.getImageData(0, 0, 400, 320);\nvar binary &#x3D; new Uint8Array(img.data.length);\nfor (var i &#x3D; 0; i &lt; img.data.length; i++) &#123;\n  binary[i] &#x3D; img.data[i];\n&#125;\nws.send(binary.buffer);\n\n4.7 webSocket.bufferedAmount实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。\n\n\nvar data &#x3D; new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount &#x3D;&#x3D;&#x3D; 0) &#123;\n  &#x2F;&#x2F; 发送完毕\n&#125; else &#123;\n  &#x2F;&#x2F; 发送还没结束\n&#125;\n\n4.8 webSocket.onerror实例对象的onerror属性，用于指定报错时的回调函数。\n\n\nsocket.onerror &#x3D; function(event) &#123;\n  &#x2F;&#x2F; handle error event\n&#125;;\n\nsocket.addEventListener(&quot;error&quot;, function(event) &#123;\n  &#x2F;&#x2F; handle error event\n&#125;);\n\n五、服务端的实现WebSocket 服务器的实现，可以查看维基百科的列表。\n常用的 Node 实现有以下三种。\n\nµWebSockets\nSocket.IO\nWebSocket-Node\n\n具体的用法请查看它们的文档，这里不详细介绍了。\n六、WebSocketd下面，我要推荐一款非常特别的 WebSocket 服务器：Websocketd。\n它的最大特点，就是后台脚本不限语言，标准输入（stdin）就是 WebSocket 的输入，标准输出（stdout）就是 WebSocket 的输出。\n\n举例来说，下面是一个 Bash 脚本counter.sh。\n\n\n#!&#x2F;bin&#x2F;bash\n\necho 1\nsleep 1\n\necho 2\nsleep 1\n\necho 3\n\n命令行下运行这个脚本，会输出1、2、3，每个值之间间隔1秒。\n\n\n$ bash .&#x2F;counter.sh\n1\n2\n3\n\n现在，启动websocketd，指定这个脚本作为服务。\n\n\n$ websocketd --port&#x3D;8080 bash .&#x2F;counter.sh\n\n上面的命令会启动一个 WebSocket 服务器，端口是8080。每当客户端连接这个服务器，就会执行counter.sh脚本，并将它的输出推送给客户端。\n\n\nvar ws &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#x2F;&#39;);\n\nws.onmessage &#x3D; function(event) &#123;\n  console.log(event.data);\n&#125;;\n\n上面是客户端的 JavaScript 代码，运行之后会在控制台依次输出1、2、3。\n有了它，就可以很方便地将命令行的输出，发给浏览器。\n\n\n$ websocketd --port&#x3D;8080 ls\n\n上面的命令会执行ls命令，从而将当前目录的内容，发给浏览器。使用这种方式实时监控服务器，简直是轻而易举（代码）。\n\n更多的用法可以参考官方示例。\n\n\nBash 脚本读取客户端输入的例子\n五行代码实现一个最简单的聊天服务器\n\n\n\nwebsocketd 的实质，就是命令行的 WebSocket 代理。只要命令行可以执行的程序，都可以通过它与浏览器进行 WebSocket 通信。下面是一个 Node 实现的回声服务greeter.js。\n\n\nprocess.stdin.setEncoding(&#39;utf8&#39;);\n\nprocess.stdin.on(&#39;readable&#39;, function() &#123;\n  var chunk &#x3D; process.stdin.read();\n  if (chunk !&#x3D;&#x3D; null) &#123;\n    process.stdout.write(&#39;data: &#39; + chunk);\n  &#125;\n&#125;);\n\n启动这个脚本的命令如下。\n\n\n$ websocketd --port&#x3D;8080 node .&#x2F;greeter.js\n\n官方仓库还有其他各种语言的例子。\n七、参考链接\nHow to Use WebSockets\nWebSockets - Send &amp; Receive Messages\nIntroducing WebSockets: Bringing Sockets to the Web\n\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"flask 报错BuildError","url":"/2022/11/25/flask%E6%8A%A5werkzeug.routing.exceptions.BuildError%E9%94%99%E8%AF%AF/","content":"flask返回模板文件时，抛出下列这个错误：\nBuildError\nwerkzeug.routing.exceptions.BuildError: Could not build url for endpoint &#39; welcome &#39;. Did you mean &#39;welcome&#39; instead?\ntraceback显示：\nreturn render_template(&#39;main.html&#39;,username&#x3D;current_user.username)\n网上搜了很多方法都不能解决，最后发现是main.html模板文件内的src写法有问题。src=&#39;&#123;&#123; url_for('welcome')&#125;&#125;&#39; 如果是两层单引号，保存文件时，eslint插件会自动在welcome前后添加空格，导致错误。\n&lt;iframe name=\"right\" class=\"el-main\" src='&#123;&#123; url_for('welcome')&#125;&#125;' width=\"100%\" height=\"100%\" frameborder=\"0\">\n外面改成双引号src=&quot;&#123;&#123; url_for('welcome')&#125;&#125;&quot; 即可解决。ESLINT插件就不会自动添加空格。\n&lt;iframe name=\"right\" class=\"el-main\" src=\"&#123;&#123; url_for('welcome')&#125;&#125;\" width=\"100%\" height=\"100%\" frameborder=\"0\">","categories":["开发"],"tags":["原创","flask"]},{"title":"hexo d博客部署报错","url":"/2022/11/14/hexo%E6%8A%A5%E9%94%99/","content":"hexo d 博客部署的时候出现下面这各错误，是网络问题，换个代理节点就好了。\nfatal: unable to access &#39;https:&#x2F;&#x2F;github.com&#x2F;xx&#x2F;xx.github.io&#x2F;&#39;: OpenS\nSL SSL_read: Connection was reset, errno 10054\nFATAL &#123;\n  err: Error: Spawn failed\n      at ChildProcess.&lt;anonymous&gt; (D:\\Blog\\hexo\\node_modules\\hexo-util\\lib\\spawn\n.js:51:21)\n      at ChildProcess.emit (events.js:315:20)\n      at ChildProcess.cp.emit (D:\\Blog\\hexo\\node_modules\\cross-spawn\\lib\\enoent.\njs:34:29)\n      at Process.ChildProcess._handle.onexit (internal&#x2F;child_process.js:277:12)\n&#123;\n    code: 128\n  &#125;\n&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;do\ncs&#x2F;troubleshooting.html\n\n","categories":["博客"],"tags":["原创","hexo"]},{"title":"Hexo 自定义字体方法","url":"/2022/11/19/hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E6%96%B9%E6%B3%95/","content":"\n            可使用在线字体和本地字体。\n          \n\n本地使用系统字体\n找到fluid文件夹下的source&#x2F;css目录,新建一个custom_css.css文件，里面配置字体风格，类似：\n\nhtml,\nbody,\nheader,\n.markdown-body &#123;\n    font-family: Verdana, Arial, Helvetica, sans-serif;\n    font-size: 16px;\n&#125;\n\n\n找到_config.fluid.yml配置文件，引入custom.css目录即可。\n\n本地使用自定义字体如果不满足系统自带字体，可以去google-webfonts-helper这个网站下载。\n找到想要的字体后，将字体解压出来，置于根目录下的fonts文件夹（如果没有就新建一个）。然后复制google-webfonts-helper字体的CSS代码到上述custom.css文件内，接着找到themes&#x2F;fluid&#x2F;source&#x2F;_variables&#x2F;base.styl文件，在\n&#x2F;&#x2F; font\n$font-size &#x3D; theme-config(&quot;font.font_size&quot;, &quot;16px&quot;)\n$letter-spacing &#x3D; theme-config(&quot;font.letter_spacing&quot;, &quot;0.02em&quot;)\n$font-family &#x3D; theme-config(&quot;font.font_family&quot;, &quot;PT Sans&quot;,&quot;var(--font-family-sans-serif)&quot;)\n$code-font-size &#x3D; theme-config(&quot;font.code_font_size&quot;, &quot;85%&quot;)\n中的$font-family = theme-config(&quot;font.font_family&quot;,后面添加字体名。然后保存，hexo clean &#x3D;&#x3D;&gt; hexo g &#x3D;&#x3D;&gt; hexo d 就OK。\n\n备用链接 ：https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-facehttps://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family\n\n","categories":["博客"],"tags":["原创","Hexo"]},{"title":"PyEcharts学习总结","url":"/2022/11/13/pyecharts%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"\npyecharts 分为 v0.5.x 和 v1.0.0+ 两个版本，这篇总结针对新版本。\n\n\n本文不包含基础例子的演示，主要记录一些细节方面的理解。简介中推荐的网站有相关示例。\n\n一、简介 – Echarts &amp; PyEchartsEcharts 是一个基于 JavaScript 的图表库，用于在 HTML 中生成可交互的图表。关于更多 js 图表库可以参考 CSDN 上的 这篇博客。PyEcharts 旨在提供在 Python 中使用 Echarts 的 API，以便将数据可视化的流程整合到 Python 数据处理的流程当中。\n以下是四个文档和示例网站，各有特点。利用好这几个网站基本上就可以解决所有可能遇到的问题，而不需要在搜索引擎中漫无目的地翻查。（喜欢这篇文章的新手朋友，建议先撸一遍下面 gallery.pyecharts.org 里面的代码再来看，因为文章写得不好，入门者很可能一头雾水）\n\nEcharts\nhttps://www.w3cschool.cn/echarts_tutorial （配置项的文档非常详尽）\nhttps://echarts.apache.org/zh/index.html （示例中有很多出色的可视化例子）\n\n\nPyEcharts\nhttps://pyecharts.org/#/zh-cn/intro （PyEcharts 的 API 文档）\nhttps://gallery.pyecharts.org/#/README （PyEcharts 绘图的示例和代码）\n\n\n\nEcharts首先通过一个简单的例子了解 Echarts 的工作方式，注意到使用 Echarts 需要 HTML 语言基础，进阶则需要 js 和 css 的基础。（如果只是在 Python 中进行可视化，对前面三件套的要求不高，基本上看看例子就能摸索出来写法，编程语言都是共通的。）\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n  &lt;title>MyCharts&lt;/title>\n  &lt;!-- 引入echarts.js 很多cdn源都可以引用 视情况使用 -->\n  &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@latest/dist/echarts.min.js\">\n  &lt;/script>\n&lt;/head>\n&lt;body>\n  &lt;!-- 图表容器--整个网页就是一个div 内容都是通过echarts.min.js渲染出来的 -->\n  &lt;div id=\"main\" style=\"width: 600px;height:400px;\">&lt;/div>\n  &lt;!-- 图表渲染的js代码 -->\n  &lt;script type=\"text/javascript\">\n      // 初始化echarts实例\n      var myChart = echarts.init(document.getElementById('main'));\n      // 指定图表的配置项和数据\n      var option = &#123;\n          // option变量的内容是一个js对象类型(Object) 类似python中的字典类型\n          // option对象的属性(Attribute)可以赋值为各种js基本类型 包括对象类型\n          title: &#123;text: 'ECharts 入门示例'&#125;, // 图表标题选项\n          tooltip: &#123;&#125;,                      // 工具提示选项\n          legend: &#123;data:['销量']&#125;,          // 图例选项\n          xAxis: &#123;data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"]&#125;,\n          yAxis: &#123;&#125;,  // 缺省时没有标注\n          series: [&#123;  // series就是图表主体部分用到的数据\n              name: '销量',   // name参数用于区分多个series\n              type: 'bar',    // 图表类型 可以是line,scatter等\n              data: [5, 20, 36, 10, 10, 20] // 图表主体的数据 这里就是bar的长度\n          &#125;]\n      &#125;;\n      // 使用刚指定的配置项和数据显示图表。\n      myChart.setOption(option);\n  &lt;/script>\n&lt;/body>\n&lt;/html>\n\n\n将上述代码保存为 html 文件在浏览器打开就可以看到图表了（左图），如果直接将 &lt;head&gt; 中引用的 js 文件保存到本地，将引用链接改为本地文件链接，那么无网络的情况下也可以显示。清楚了原理很容易就可以画出自己想要的图表，比如将上述代码中 option.series[0].type 的值改为 line，条形图就变成折线图了（右图）。将 option.series[0].data 中的数据改为自己的数据，就可以可视化自己的数据了。\nPyEcharts但是在实际的数据可视化中，我们的数据可能要成千上万行，绘制的图表也有很多个，不可能手动复制粘贴去修改，这时候就需要用到 pyecharts 了。首先通过 pip install pyecharts --upgrade 安装或更新到最新版。绘制以上同样的图表，只需要以下的代码：\n# 引入子模块\nfrom pyecharts import charts as pyc\nfrom pyecharts import options as opts\n# 这里链式调用，也可以先实例化一个 charts 对象再一步步设置\nbar = (\n    # 实例化：\n    pyc.Bar()\n    # 对应上面html文档中的 option.XAxis.data：\n    .add_xaxis([\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"])\n    # 对应上面html文档中的 option.series：\n    # 注意到 option.series 是js数组类型，也就是可以添加多个序列\n    .add_yaxis(\"销量\", [5, 20, 36, 10, 10, 20]) \n    # global_opts 对应上面html文档中的 option 的属性\n    # 例如 option.title 通过 title_opts 参数设置\n    .set_global_opts(title_opts=opts.TitleOpts(title=\"Echarts 入门示例\"))\n)\n# 在当前目录生成默认名称为 render.html 的文档\nbar.render()\n\n通过这个例子就可以理解，pyecharts 就是通过 python 代码设置 js 代码里面的变量，然后生成 html 文档。生成的 html 文档不同的是 pyecharts 会把缺省的参数自动填充默认值，所以生成的 html 代码会比上面自己写的长很多。从这里也可以明白为什么说使用 pyecharts 要使用开始介绍的两个 echarts 的网站，因为参数都是对应的。pyecharts 文档中没查到的参数设置，可以到 echarts 的教程上面查找。\n二、常用图表pyecharts 整个项目结构见下图。绘图时用到的所有类都在 pyecharts.charts 子模块中，pyecharts.charts 中所有的图表类都直接或间接继承于 pycharts.Base 类。由于图表类型不同，中间又有不同图表类型的子类，如直角坐标系图表类、 3D 图表类、极坐标图表类，等。相同图表类型的图表绘图方法高度一致，在文章开始介绍的两个 pyecharts 网站中可以找到 API 文档和图表示例代码，比较简单，这里就不做示例了。\n\n三、选项配置选项配置主要是 set_global_opts 和 set_series_opts 两个方法，顾名思义前者设置的是对应的 js 代码中 option 变量的属性，后者设置的对应的 js 代码中 option.series 的属性。\n常用 options常用的 options 分为四类，对应一般绘图时的四个步骤，注意不是所有图表类的对应方法都通用，在 pyecharts.org 中参考对应方法的文档使用，或者在 ipython 中使用魔术命令： Bar.set_global_opts?、opts.ItemStyleOpts? 等查看对应参数和用法。另外这些 options 是层层嵌套的，比如在 opts.AxisOpts 里面，又有用到 opts.LabelOpts 来定义坐标轴标签的样式，这里就不深挖了，只列举第一层的常用选项。\n# 图表类的 init_opts，设置图表整体风格，大小等\nfrom pyecharts import globals as glbs\nBar(init_opts=opts.InitOpts(\n    glbs.ThemeType.DARK, bg_color='#1a1c1d', width='100%', height='400px'))\n\n# 使用 add 方法（泛指 add_yaxis, add_schema 等）时的 options\nitemstyle_opts = opts.ItemStyleOpts()           # 元素样式，如散点图的点\nemphasis_itemstyle_opts = opts.ItemStyleOpts()  # 元素高亮样式\nlinestyle_opts = opts.LineStyleOpts()           # 用于 Line.add_yaxis 里面\n\n# set_series_opts 中的 options\ntooltip_opts = opts.TooltipOpts()       # 工具提示\nitemstyle_opts = opts.ItemStyleOpts()   # 元素样式\nlabel_opts = opts.LabelOpts()           # 标签样式，例如条形图顶部显示的数值\nareastyle_opts = opts.AreaStyleOpts()   # 区域样式，例如线形图与坐标轴围成的区域\n\n# set_global_opts 中的 options\ntitle_opts &#x3D; opts.TitleOpts()           # 标题、副标题及其字体颜色等样式\nxaxis_opts &#x3D; opts.AxisOpts()            # 坐标轴的样式，如轴线样式，文字旋转等\nyaxis_opts &#x3D; opts.AxisOpts()            # 同上\ndatazoom_opts &#x3D; opts.DataZoomOpts()     # 数据过多时可以使用类似滚动条的插件\nlegend_opts &#x3D; opts.LegendOpts()         # 图例是否显示、样式及其位置等\nvisualmap_opts &#x3D; opts.VisualMapOpts()   # 视觉映射，例如按系列值的大小给元素着色\ntoolbox_opts &#x3D; opts.ToolboxOpts()       # 在图中加入放大缩小，导出图片等工具按钮\ngraphic_opts &#x3D; [opts.GraphicGroup]      # 加入自定义的图形，如多边形，水印等内容\n\n经验总结要注意到 pyecharts.options 这个类，上述的两个方法的参数都是赋值为 pyecharts.options 的子类，例如 pyecharts.options.AxisOpts、pyecharts.options.LabelOpts，等。除了使用 options 的子类，还可以直接使用字典（如前文所述，Python 中的字典就相当于 js 的对象，把对应的字典传给对应的属性对象就可以了）。例如\nLine().add_xaxis(...).add_yaxis(...).set_global_opts(\n    legend_opts=opts.LegendOpts(is_show=True)\n)\n\n可以写为：\nLine().add_xaxis(...).add_yaxis(...).set_global_opts(\n    legend_opts=&#123;'show': True&#125;\n)\n\n注意到这里也不是严格对应的，比如在 options 类的参数中是 is_show，在字典中的键是 show。个人觉得这是 pyecharts 的一个不足的地方，主要是因为这是一个 Python 的项目，它得默认使用者不懂 js，于是只能弄一堆的 options 对象（pyecharts.options 里面有大约 100 个 ***Opts 对象）和一堆的 init 参数，虽然是很好地 “Python 化” 了，但是也搞到 API 十分的复杂，难记。如果在某些地方适当地使用 js 里面的内容，那整个逻辑会简化很多。可以看到文章一开始使用 echarts 绘图的时候就是一个很简单的逻辑。\n另外这些 options 并不是全在上述两个方法中使用，比如 add_yaxis 中也有很多 options 参数，感觉有点混乱。而且也不是所有图表通用的，只能说是在大部分图表中通用。例如\nScatter().add_xaxis(...).add_yaxis(...).set_series_opts(\n    emphasis_itemstyle_opts=opts.ItemStyleOpts(color='red')\n)\n\n这段代码设置了散点图当鼠标悬停在某个点上时，该点的高亮颜色。在 Line、Bar 等很多图表中都适用，但是在地理图 Geo 的 set_series_opts 方法中没有这个参数。\n并且，尝试得多了，你可能会发现：\n\n在 echarts 中支持的属性，在 pyecharts 的 API 中不支持\n在 pyecharts 中支持的参数，写到 html 中时被直接无视，也不报错\n在 pyecharts 中不支持的参数，你给它直接写到 html 文档的 js 代码中时，它是有效的\n\n等等各种奇怪的问题，这也不知道是 pyecharts 不成熟的地方，还是我自己没理解透彻。总之说明了一个道理，如果想要精通 pyecharts，随心所欲地绘制各种图表，还是要从学习 echarts 入手。\n四、进阶技巧基础的绘图例子都可以在文章开始的网站中找到示例代码，下面介绍一下一些比较有用的进阶技巧。\n更换 echarts.min.js 的引用源pyecharts 默认的源是 https://assets.pyecharts.org/assets/，一般国内网络加载较慢，可以通过以下代码采用 CDN 加速。当然，也可以像简介部分提到的，将 echarts.min.js 保存到任意位置然后引用，比如 localhost。如果这样则要注意，有些图不仅仅会用到 echarts.min.js，还需要用到其他的 js 资源，例如地图、词云图等。\ncdn &#x3D; &quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;echarts@latest&#x2F;dist&#x2F;&quot;\npyecharts.globals.CurrentConfig.ONLINE_HOST &#x3D; cdn\n\n参数数据类型一般我们会使用 pandas 处理数据，然后绘图。这时候要注意 pandas 里面的数值型使用的不是内置类型，而是 numpy 的数据类型。而 echarts 是不认识 numpy 数据类型的，这时候会画一个空的没有数据的图，让人一脸懵。可以如下显式更改数据类型：\nScatter().add_xaxis(\n    [int(i) for i in df.index]\n).add_yaxis(\n    [float(n) for n in df['col']]\n)\n# 注意，以下写法是不行的\n# 虽然传递的参数是内置类型float，但是pandas还是会自作主张给你改成numpy.float64\ndf['col'].astype(float)\n\n遇到不支持或无效的参数怎么办遇到上一小节最后提到的那些问题，比如某些属性在 echarts 中有效，但是在 pyecharts 中没有对应参数或者无效，这种情况我们最直接的思路就是手动去改 html 里面 js 代码。还是以简介部分那个图为例，比如我想微调一下主图在整个画布中的位置（可能是出于想用 overlap 方法在主图上叠加其他图表等原因），在 echarts 中可以如下实现：\n\n通过 grid 属性定义主图左上角的坐标和右下角的坐标，坐标可以是相对值，也可以是数值表示的绝对值，单位是 css 中的 px。为了好理解，这里故意将位置调得夸张一点，实际上我们经常需要微调主图的位置来适应布局。但是在 pyecharts 的常用图表类里是不能直接设置这个 grid 属性的（反正我没找到）：\n\n可以看到 global options 没有该参数。series options 里面倒是有这个参数，但是设置的不是同一个东西了。唯一的可能就是使用 pyecharts.charts.Grid 这个图表类时才允许加入 grid 参数，如下图。但是 Grid 类和其他常用图表类（例如 Bar）直接继承的类是不一样的，所以用 Grid 类打包图表之后会导致很多原本支持的设置失效。\n\n对此一开始我想到一个很笨拙的办法：强行在 js 中写入属性，替代手动修改属性的过程。首先按照简介中的代码，生成一个 render.html，然后如下写入属性：\ndef write_js(file, locate, write):\n    with open(file, 'r') as f:\n        html = f.read()\n    with open(file, 'w') as f:\n        f.write(html.replace(locate, write)) \n\n# locate 用于定位修改位置，这里建议使用 option 里面参数来定位\n# 比如这里准备写到 \"title\" 属性的前面：\nlocate = '\"title\": [\\n' # 尽可能多的字符，否则可能定位错\n# 需要写入的属性\nwrite = '\"grid\": &#123;\"x\": \"20%\", \"y\": \"30%\", \"x2\": \"30%\", \"y2\": \"20%\"&#125;, \\n'\nwrite_js('render.html', locate, write+locate)\n\n\n好笨的方法，千万别学。后来经过进一步对 pycharts 图表类属性的研究，发现可以直接这样就搞定：\n# 首先绘图\nbar = Bar().add_xaxis(...).add_yaxis(...).set_global_opts(...)\n# 然后还缺什么属性，直接往 options 里面添加，然后 render\nbar.options['grid'] = &#123;\"x\": \"20%\", \"y\": \"30%\", \"x2\": \"30%\", \"y2\": \"20%\"&#125;\nbar.render()\n# 注意到 bar.options 是一个字典\n# 它的内容就是生成的 html 文档的 js 代码里面的 option 变量的内容\n\n运用 css 和 js 控制视觉效果如果想要随心所欲地自定义视觉效果，需要了解一些 css 的基础知识。如果仅仅使用 Python 代码，我们定义一个散点图中的散点的颜色时，可以这样写：\nScatter().add_xaxis(index_data).add_yaxis(\n    series_name, value_data, itemstyle_opts=opts.ItemStyleOpts(color='red')\n)\n\n运用 css 代码，我们可以将 ItemStyleOpts 写成：\nopts.ItemStyleOpts(color='#ff0000')\nopts.ItemStyleOpts(color='rgba(255,0,0,1)')\n\n或者运用图表库提供的函数：\nfrom pyecharts.commons.utils import JsCode\n\nopts.ItemStyleOpts(color=JsCode(\n    # 引入echarts.min.js后就可以使用echarts库的方法\n    ''' new echarts.graphic.RadialGradient(\n        0.5, 0.5, 0.5,  \n        [&#123;offset: 0, color: 'rgba(255,0,0,1)'&#125;,\n        &#123;offset: 1, color: 'rgba(0,0,255, 1)'&#125;]\n    ) '''\n))\n\n直接在浏览器 console 中更改 option（还是简介中那个图），结果如下：\n\n或者对于一些在 API 中为数值常量的参数，可以通过 js 变成变量。例如在散点图中定义点的大小，可以通过 js 使每个点显示不同大小：\nScatter().add_xaxis(...).add_yaxis(\n    series_name, data_pair,\n    # 固定大小：symbol_size=5,\n    # 由数据值决定大小：\n    symbol_size=JsCode('function (data) &#123;return data[1]*10;&#125;')\n)\n\n这里用到的 js 代码其实并不复杂，Python 混 Java 的感觉，学过上述两种的凭感觉都会写。感兴趣的可以学一下。\n运用 js 控制交互效果这里经常用于改变工具提示（tooltip），就是鼠标悬停某个数据点时显示出来的东西。以之前做的一个图表为例，主要涉及的 option 如下：\n\n默认情况下图表的工具提示格式是：series_name \\n x轴标签 y轴的值，但是如果需要自定义格式，就要使用 js 回调函数。这个在 pyecharts.org 上也提到，但不是很详细。具体代码如下，参考上图给出的 option 就可以理解了。\nfrom pyecharts.commons.utils import JsCode\ntooltipJS = '''\n    function (param) &#123; \n        // param参数接收的就是上图中的option.series.data这个数组中对应的元素\n        var line1 = 'name: ' + param.data[0] + '&lt;br/>';\n        var line2 = 'value1: ' + param.data[1] + '&lt;br/>';\n        var line3 = 'value2: ' + Math.ceil(10**param.data[2]); // 引用js内置函数\n        return line1 + line2 + line3;   // return的内容就是到时工具提示显示的内容\n    &#125;\n'''\n# 然后通过 JsCode 传给 TooltipOpts 的 formatter\nScatter().set_global_opts(\n    tooltip_opts=opts.TooltipOpts(formatter=JsCode(tooltipJS))\n)\n\n那么问题来了，上图的数据部分是绘图时传给 series 的参数，但是如果我还想在 tooltip 里说点别的东西怎么办？可以在 add_yaxis 时强行传进去再使用 js 回调函数。以下是一个完整的绘图例子：\nfrom pyecharts import charts as pyc\nfrom pyecharts import options as opts\nfrom pyecharts import globals as glbs\nbar = pyc.Bar(\n    init_opts=opts.InitOpts(theme=glbs.ThemeType.DARK, bg_color='#1a1c1d')\n).add_xaxis(['A', 'B', 'C']).add_yaxis(\n    'test charts', [1, 2, 3]\n)\nbar.render()\n\n\n如上图，这时是默认的工具提示格式，但是如果我想让它不显示为数值 [1, 2, 3]，而是描述性的信息，例如 [&#39;低&#39;, &#39;中&#39;, &#39;高&#39;] 或者更丰富的信息，那可以这样写：\nbar = pyc.Bar(\n    init_opts=opts.InitOpts(theme=glbs.ThemeType.DARK, bg_color='#1a1c1d')\n).add_xaxis(['A', 'B', 'C']).add_yaxis(\n    'test charts', \n    [(0,1,'低','更多信息'), (1,2,'中','更多信息'), (2,3,'高','更多信息')]\n    # 通过元组列表强行传进更多的信息\n    # 元组第一位是对应 xaxis 的序号，第二位是序列的值 这里就是bar的长度\n    # 剩下的爱加多少加多少，每个点写一篇800字作文都行\n).set_global_opts(\n    tooltip_opts=opts.TooltipOpts(formatter=JsCode(\n        '''\n        function (param) &#123;\n            var line1 = 'index: ' + param.data[0] + '&lt;br/>';\n            var line2 = 'value: ' + param.data[1] + '&lt;br/>';\n            var line3 = 'info1: ' + param.data[2] + '&lt;br/>';\n            var line4 = 'info2: ' + param.data[3];\n            return line1 + line2 + line3 + line4;\n        &#125;\n        '''\n    ))\n)\nbar.render()\n\n结果如下。如果没看懂这段代码，可以将 html 源码 render 出来，对应着看，自然就理解了。\n\n再进一步深入，以上方法也不是万能的。例如在特别的图表中，根本就没有 add_yaxis 方法。比如 Geo 图表类型，是通过 add 方法传入 series 数据，于是传参的格式跟上面方法又不同。这时可以通过以下代码传入主图以外的数据，以作 tooltip 等其他用途：\nGeo().add_schema(...).add_coordinate(...).add(\n    series_name,\n    [('A', [1,2,3]), ('B', [4,5,6]), ('C', [7,8,9])]\n    # 这里传入的数据也是一个元组列表，但是它仅限两位的元组\n    # 第一位是地图中区域的名称，也就是到时会在地图中 A, B, C 三个地点标上散点\n    # 第一位在 js 中通过 param.data.name 引用\n    # 第二位是包含额外数据的列表，通过 param.data.value(一个js数组) 引用\n).set_global_opts(\n    tooltip_opts=opts.TooltipOpts(formatter=JsCode(\n        '''\n        function (param) &#123;\n            return param.data.name + ' | ' +\n                'info1:' + param.data.value[0] + \n                ', info2:' + param.data.value[1] + \n                ', info3:' + param.data.value[2];\n        &#125;\n        '''\n        # 当鼠标悬停在 B 点时，返回“B | info1: 4, info2: 5, info3: 6”\n    ))\n)\n\n更复杂的情况是，加上额外数据后格式就是不对，或者会影响图表的其他组件。比如在上例的 set_global_opts 中加入了 visualmap 组件时，直接传入额外数据会导致 visualmap 显示不正常。这里我没有找到好的办法，所以想了一个_投机取巧_的方法。就是由于 python 字典跟 js 对象的格式是一样的，可以直接生成个字典的字符串写入 js ，然后再引用。于是上例可以写成：\ndata_pair = [('A', 10), ('B', 100), ('C', 1000)] \n# 上面的 10, 100, 1000 就是用在 visualmap 中的数据值\n# 下面的则是用于 tooltip 的额外数据\nextend_data = &#123;'A': [1,2,3], 'B': [4,5,6], 'c': [7,8,9]&#125;\ntooltip_data = [&#123;'name': k, 'value': v&#125; for k, v in extend_data.items()]\n# 返回 tooltips 的函数\ntooltipjs = r'''\n    function (param) &#123;\n        var tooltip_data = __MARKER__; // 到时在 __MARKER__ 这里写入要传的数据\n        for (int i=0; i&lt;tooltip_data.length; i++) &#123;         // 遍历\n            if (param.data.name == tooltip_data[i].name) &#123;  // 匹配\n                var values = tooltip_data[i].value;         // 提取额外数据\n            &#125;\n        &#125;\n        // 返回给 tooltips\n        return param.data.name + ' | ' +\n            'info1:'+values[0]+', info2:'+values[1]+', info3:'+values[2];\n    &#125;\n'''.replace('__MARKER__', str(tooltip_data))    # 在这里加入了额外的数据\n# 绘图\nGeo().add_schema(...).add_coordinate(...).add(\n    series_name, data_pair\n).set_global_opts(\n    tooltip_opts=opts.TooltipOpts(formatter=Jscode(tooltipjs)),\n    visualmap_opts=opts.VisualMapOpts()\n)\n# 可以看到在调用 pyecharts 绘图时没有用到额外的数据，只有 data_pair\n# 用于 tooltip 的数据是写在 js 字符串里偷偷传进去的\n# 这时 tooltip 的效果跟上例一样，但是上例的写法不支持 visualmap\n\n到这基本就到头了，因为上面的方法虽然很繁琐，但是基本可以所向披靡，对任何的图都通用。并且除了 tooltips，其他的数据交互的问题也可以按类似的思路来解决。\n五、总结整体思路回到开始的问题：如何用 pyecharts 绘制一切你想象得到的交互式图表？根据前文的内容可以总结以下的流程：\n\n1） 根据需求，确定图表类型、基本内容、风格样式等\n2） 粗略画个草图，如果不会画就上 gallery.pyechart.org 上抄个类似的\n3） 通过各种 options 修改图中的细节部分，详细的文档在 pyecharts.org 上\n4） 实在找不到的设置，在简介提到的 Echarts 网站中找配置，再写进 options 字典里\n5） 跟据前面提到的技巧及其思路，修改还不符合要求的地方\n\n实例验证最后用一个实例验证一下上述流程是否真的有用。第一步，先找一个属于常用图表类型的，并且相对较复杂的图。这里到 Apache 官网的示例上去找，就用如下这个图，看起来花里胡俏挺唬人的。这个图印象中 gallery.echarts.org 好像有个类似的例子，这里我们假装不知道先来自己做一下。\n\n首先把 option 的内容折叠起来以免自己偷看作弊。它上面的数据没有直接写入 option 变量，而是用 jquery 加载的，我没找到接口在哪，所以就在 option 里面加了个 dataView 工具，然后运行，在数据视图中将数据 copy 下来，保存为 data.csv（文末可以下载）。\n第二步，粗略地画个草图。就是一个主题为 pyecharts.globals.ThemeType.DARK 的折线图，横轴为时间，纵轴为 AQI 数值。页面上加了标题、工具箱、图例、数据缩放工具四个组件。\nimport pandas as pd\nfrom pyecharts import charts as pyc\nfrom pyecharts import options as opts\nfrom pyecharts import globals as glbs\n\ndata = pd.read_csv('data.csv', sep='\\t')\nline = pyc.Line(init_opts=opts.InitOpts(theme=glbs.ThemeType.DARK, width='100%')\n).add_xaxis(\n    list(data.iloc[:,0])\n).add_yaxis(\n    'Beijing AQI', list(data.iloc[:,1])\n)\nline.render()\n\n首先画个最简单的图，结果长下面那样。对比一下，缺了上面提到的三个组件。图例默认有了，但是不是我们想要的样子。工具提示显示格式一样了，但是触发方式不一样，下图中要悬停到具体的点上才能触发。折线上多了数据标签，主图背景少了些分割线，等等。\n\n然后先简单地使用默认参数，把完整的 options 加上去。可以看到加上组件了，已经离目标接近很多了。\nline.set_series_opts(\n    label_opts=opts.LabelOpts(is_show=False)\n).set_global_opts(\n    title_opts=opts.TitleOpts(title='Beijing AQI'), \n    legend_opts=opts.LegendOpts(),\n    visualmap_opts=opts.VisualMapOpts(), \n    datazoom_opts=opts.DataZoomOpts(), \n    tooltip_opts=opts.TooltipOpts(),\n    toolbox_opts=opts.ToolboxOpts()\n)\nline.render()\n\n\n第三、四、五步其实就是一个循环迭代的过程，用这个思路来修改每一个 options。接下来根据上图与原图不同的地方，具体定义组件的 options 参数：\nTitle 这里位置太靠边了，原图离最左边有点空隙：\nline.set_global_opts(\n    title_opts=opts.TitleOpts(title='Beijing AQI', pos_left='1%'), \n)\n\nLegend 这里想了很久，不知道怎么改成原图那样。后来跳过了，做下面的内容才发现原图那个不是 Legend，而是 Visual Map 产生的图例。所以这里就简单把 Legend 禁用了就行了：\nline.set_global_opts(\n    legend_opts=opts.LegendOpts(is_show=False),\n)\n\nViusal Map 这里明显的区别是，原图那个是离散的，这里目前是连续的，所以先找个参数将它离散化。然后需要定义一下分割的区间。这里我先是凭感觉写了个参数，发现不对，便上 官网 查看了一下文档如下。至于每个区间的颜色，可以用取色器在原图获取：\n# 自定义的每一段的范围，以及每一段的文字，以及每一段的特别的样式。例如：\n# pieces: [\n#   &#123;\"min\": 1500&#125;, // 不指定 max，表示 max 为无限大（Infinity）。\n#   &#123;\"min\": 900, \"max\": 1500&#125;,\n#   &#123;\"min\": 310, \"max\": 1000&#125;,\n#   &#123;\"min\": 200, \"max\": 300&#125;,\n#   &#123;\"min\": 10, \"max\": 200, \"label\": '10 到 200（自定义label）'&#125;,\n#   &#123;\"value\": 123, \"label\": '123（自定义特殊颜色）', \"color\": 'grey'&#125;,\n#   &#123;\"max\": 5&#125;     // 不指定 min，表示 min 为无限大（-Infinity）。\n# ]\npieces: Optional[Sequence] = None,\n\nline.set_global_opts(\n    visualmap_opts=opts.VisualMapOpts(\n        is_piecewise=True, pos_top=50, pos_right=10,\n        pieces=[\n            &#123;'min':0, 'max': 50, 'color': '#93CE07'&#125;,\n            &#123;'min':50, 'max': 100, 'color': '#FBDB0F'&#125;,\n            &#123;'min':100, 'max': 150, 'color': '#FC7D02'&#125;,\n            &#123;'min':150, 'max': 200, 'color': '#FD0100'&#125;,\n            &#123;'min':200, 'max': 300, 'color': '#AA069F'&#125;,\n            &#123;'min':300, 'color': '#AC3B2A'&#125;\n        ]\n    ), \n)\n\nData Zoom 组件默认显示 20%-80%，看一下文档，发现有个 start_value 参数，由于原图中就是显示最后一部分，所以可以使用这个参数搞定。但是第一次试了发现不行，原因是它已经给开始结束位置设置了默认值，所以要先将这两个值设为空值，start_value 参数才有效。另外发现原图是可以在主图里面直接拖动的，所以要改一下 type 参数。这里就出现问题了，改了 type 之后，里面可以拖动了，但是外面的滚动条不见了。这里只好查看原图的代码抄答案，原来它用数组的形式定义了两个 Data Zoom 组件，一个在里面，一个在外面：\nline.set_global_opts(\n    datazoom_opts=[\n        opts.DataZoomOpts(\n            start_value='2014-06-01', range_start=None, range_end=None\n        ), \n        opts.DataZoomOpts(type_='inside')\n    ], \n)\n\nTooltip 组件需要更改触发方式，简单加上 trigger 参数即可：\n1\nline.set_global_opts(tooltip_opts&#x3D;opts.TooltipOpts(trigger&#x3D;&#39;axis&#39;))\n\nToolbox 组件多了一堆按钮，简单研究一下文档，把不必要的删掉就 OK。实际写时发现 pyecharts 的那个缺点又出现了，就是太多 options 对象。执行 opts.ToolBoxFeatureOpts? 就可以看到，可以说看了头皮发麻。所以这里用字典传参，只需要把 python 中的变量名用下划线分割单词的习惯，改成 js 中用首字母大写分割单词，参数基本就对应上了。然后用字典代替 options 对象就行了。然后还要改一下它的位置，原图是靠右对齐，并且离最右边留有一点空隙，这里因为也已经有默认参数，一样要先把默认参数置空：\nline.set_global_opts(\n    toolbox_opts=opts.ToolboxOpts(\n        pos_left=None, pos_right=10,\n        feature=&#123;'dataZoom': &#123;&#125;, 'restore': &#123;&#125;, 'saveAsImage': &#123;&#125;&#125;\n    ),\n)\n\n然后好像还差点什么？没错，Y 轴的分割线。估计应该是在 yaxis_opts 里添加，于是试一下。发现分割线是有了，但是还差那些带箭头的虚线，查了一下文档，发现应该在 set_series_opts 里面通过 opts.MarkLineOpts 设置：\nline.set_series_opts(\n    markline_opts=opts.MarkLineOpts(\n        label_opts=opts.LabelOpts(position='end'),\n        linestyle_opts=opts.LineStyleOpts(color='#333'),\n        data=[&#123;'yAxis': y&#125; for y in [50, 100, 150, 200, 300]]\n    )\n)\n\n最后主图的位置和原图不太一样，通过 grid 属性改一下。参考第四节中提到的关于参数无效的问题：\nline.options['grid'] = &#123;'left': '6%', 'right': '15%', 'bottom': '12%'&#125;\n\n结果如下，基本与原图一样了。有细微区别是因为 Apache 网站上的图表容器跟这里的不一样，并且上面的网页截图时浏览器开了扩展 DarkReader，所以颜色也有点改变的地方。\n\n在新标签页打开交互式图表 | 下载完整绘图代码 | 下载数据\n\n\n\n鸣谢 &amp; 推荐：@AwesomeTang\nEND\n\n原文链接：https://paradiseeee.github.io/2020/12/21/PyEcharts-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/\n\n\n","categories":["数据分析"],"tags":["原创","Python"]},{"title":"Python 系统模块常用方法","url":"/2022/11/11/python%E4%B8%ADsys%EF%BC%8Cos%EF%BC%8Ctime%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"sys模块sys.argv: 实现从程序外部向程序传递参数。位置参数argv[0]代表py文件本身，运行方法 python xx.py 参数1，参数2 。。\nself = sys.argv[0]\nname = sys.argv[1]\nage = sys.argv[2]\nprint self, name, age\n\nsys.getdefaultencoding(): 获取系统当前编码，一般默认为ascii。print sys.getdefaultencoding()\n\nsys.setdefaultencoding(): 设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（python2.7中可能需要这么做）\nreload(sys)\nsys.setdefaultencoding('utf8')\n\nsys.path: 获取指定模块搜索路径的字符串集合sys.path\n\nsys.platform: 获取当前系统平台。print sys.platform\n\nsys.exit()功能：执行到主程序末尾，解释器自动退出，但是如果需要中途退出程序，可以调用sys.exit函数，带有一个可选的整数参数返回给调用它的程序，表示你可以在主程序中捕获对sys.exit的调用。（0是正常退出，其他为异常）’’’\nfor i in range(1, 10):\n    print '第%s次:' % i, i\n    if i == 5:\n        print '第五次退出'\n        sys.exit(0)\n\nos模块1. os.name()——判断现在正在实用的平台，Windows 返回 ‘nt’; Linux 返回’posix’print os.name()\n\n2. os.getcwd()——得到当前工作的目录。print os.getcwd()\n\n3. os.listdir()——指定所有目录下所有的文件和目录名。print os.listdir(&#39;.&#39;)\n\n4. os.remove()——删除指定文件os.remove(&#39;aaa.txt&#39;)\n\n5. os.rmdir()——删除指定目录os.rmdir(&#39;C:&#x2F;&#x2F;Users&#x2F;xiaoxinsoso&#x2F;Desktop&#x2F;aaa&#39;)\n\n6. os.mkdir()——创建目录,注意：这样只能建立一层，要想递归建立可用：os.makedirs()os.makedirs(&#39;aaa&#x2F;aaa&#39;)\n\n7. os.path.isfile()——判断指定对象是否为文件。是返回True, 否则Falseprint os.path.isfile(&#39;ccc.txt&#39;)\nprint os.path.isfile(&#39;aaa&#39;)\n\n8. os.path.isdir()——判断指定对象是否为目录。是True, 否则False。例：print os.path.isdir(&#39;aaa&#39;)\nprint os.path.isdir(&#39;ccc.txt&#39;)\n\n9. os.path.exists()——检验指定的对象是否存在。是True, 否则False.例：print os.path.exists(&#39;bbb&#39;)\nprint os.path.exists(&#39;aaa&#39;)\nprint os.path.exists(&#39;ccc.txt&#39;)\n\n10. os.path.split()——返回路径的目录和文件名。例：print os.path.split(&#39;C:&#x2F;&#x2F;Users&#x2F;xiaoxinsoso&#x2F;Desktop&#x2F;aaa&#x2F;ccc.txt&#39;)\n\n11. os.getcwd()——获得当前工作的目录print os.getcwd()\n\n12. os.system()——执行shell命令。注意：此处运行shell命令时，如果要调用python之前的变量，可以用如下方式：\nvar &#x3D; 123\nos.environ[&#39;var&#39;] &#x3D; str(var) \nos.system(&#39;echo $var&#39;)\n\nos.system(&#39;dir&#39;)\n\n13. os.chdir()——改变目录到指定目录14. os.path.getsize()——获得文件的大小，如果为目录，返回0print os.path.getsize(&#39;ccc.txt&#39;)\n\n15. os.path.abspath()——获得绝对路径。例：print os.path.abspath(&#39;.&#39;)\n\n16. os.path.join(path, name)——连接目录和文件名。例：print os.path.join(&#39;c:&#x2F;&#x2F;user&#x2F;xiaoxinsoso&#x2F;&#39;, &#39;wenjian.txt&#39;)\n\n17. os.path.basename(path)——返回文件名print os.path.basename(&#39;ccc.txt&#39;)\n\n18. os.path.dirname(path)——返回文件路径print os.path.dirname(&#39;C:&#x2F;&#x2F;Users&#x2F;xiaoxinsoso&#x2F;Desktop&#x2F;aaa&#x2F;ccc.txt&#39;)\n\n19. 获得程序所在的实际目录if __name__ &#x3D;&#x3D; &quot;__main__&quot;:\n    print os.path.realpath(sys.argv[0])\n    print os.path.split(os.path.realpath(sys.argv[0]))\n    print os.path.split(os.path.realpath(sys.argv[0]))[0]\n\ntime模块ticks &#x3D; time.time()\nprint &quot;当前时间戳为:&quot;, ticks\n\n获取当前时间localtime &#x3D; time.localtime(time.time())\nprint &quot;本地时间为 :&quot;, localtime\n\n获取格式化的时间localtime &#x3D; time.asctime(time.localtime(time.time()))\nprint &quot;本地时间为 :&quot;, localtime\n\n格式化日期格式化成2017-01-22 16:36:27形式print time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())\n\n格式化成Sun Jan 22 16:36:27 2017形式print time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime())\n\n将格式字符串转换为时间戳a &#x3D; &quot;Sat Mar 28 22:24:24 2016&quot;\nprint time.mktime(time.strptime(a, &quot;%a %b %d %H:%M:%S %Y&quot;))\n\n获取某月日历cal &#x3D; calendar.month(2017, 1)\nprint &quot;以下输出2016年1月份的日历:&quot;\nprint cal\n\n\ndatetime模块datetime类型时间now &#x3D; datetime.datetime.now()\nprint now\nnow &#x3D; date time.datetime.now()\nyes_time &#x3D; now + date time.timedelta(days&#x3D;-1)    # 前一天的时间\n\n\ndatetime转stringstrdatetime &#x3D; now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)     \nstrdatetime1&#x3D; now.strftime(&quot;%Y-%m-%d&quot;)     \nprint strdatetime\nprint strdatetime1\n\n\nstring转datetimedatetime1 &#x3D; datetime.datetime.strptime(strdatetime1, &quot;%Y-%m-%d&quot;)\nprint datetime1\n\n\ndatetime转时间戳time_time &#x3D; time.mktime(datetime1.timetuple())\nprint time_time\n\n\n时间戳转stringtime1 &#x3D; time.strftime(&#39;%Y-%m-%d&#39;,time.localtime(time_time))\nprint time1\n\n\ndate转datetimedate1 &#x3D; datetime.date(2012, 11, 19)\ndate &#x3D; datetime.date.today()\nprint date\nprint datetime.datetime.strptime(str(date),&#39;%Y-%m-%d&#39;) #将date转换为str，在由str转换为datetime\nprint datetime.datetime.strptime(str(date1),&#39;%Y-%m-%d&#39;) #将date转换为str，在由str转换为datetime","categories":["开发"],"tags":["转载","Python"]},{"title":"Python如何与MySQL实现交互及常用sql语句","url":"/2022/11/12/python%E8%BF%9E%E6%8E%A5MySQL/","content":"9 月初，我对 python 爬虫 燃起兴趣，但爬取到的数据多通道实时同步读写用文件并不方便，于是开始用起mysql。这篇笔记，我将整理近一个月的实战中最常用到的 mysql 语句，同时也将涉及到如何在python3中与 mysql 实现数据交换。\n关于工具&#x2F;库，特别说明下：\n1、我安装了 mysql ，并直接采用管理员身份运行命令行提示符（cmd）查看 mysql，并没有安装任何 mysql 的可视化图形界面工具。\n2、在 python 脚本中，我采用 pymysql 和 sqlalchemy 这两个库与 mysql 建立连接，用 pandas 来处理数据。\n一、建立连接与数据交互与 mysql 交互的方式，我目前共使用 4 种。其中采用管理员身份运行命令行提示符（cmd）查看 mysql，其操作图示可另写一篇。这里就不占篇幅了。mysql的可视化图形界面工具，我目前并没有用到，也没有迫切使用它的需要。另外 3 种方式都是通过 python 脚本进行。\n情境A：python 演算得出数据，想要写入数据库python 脚本已得到表格类大量数据，想要一次性写入数据库，常用代码如下：\nimport pandas as pd\n# 与 mysql 建立连接\nfrom sqlalchemy import create_engine\nconn_eng = create_engine('mysql+pymysql://username:password@localhost:3306/databasename',encoding='utf8')  \n\n# 调用 pandas 的方法，数据写入mysql\npd.io.sql.to_sql(your_df, \"table_name\", conn_eng, if_exists='append',index=False)\n\n\n表格类数据，我用的是 pandas 的 dataframe 结构。pd.io.sql.to_sql() 的参数还有许多其它用途，但上面这种是我个人使用最高频的。效果是：无需自己提前建表，将自动建新表。美中不足是：表的列属性自动生成，通常不合心意，还需检查和修改。\n如果不想用 pd.io.sql.to_sql() 或者想更精细、复杂的操作，则用到下面的情境C。\n情境B：python 脚本想从 mysql 拿到数据如果已经存在某个表格，想要向该表格提交某条指令，需返回数据，我用的是 pandas的read_sql () ，返回的数据类型是 pandas 的 dataframe。sql 查询语句挺好写的，具体总结在本文下方。\nimport pymysql\n# 与 mysql 建立连接\nconn = pymysql.connect('localhost','username','password','databasename')\n# sql 语句定义为一个字符串\nsql_search = 'select question_id from topic_monitor where is_title=0 ;'\n# 调用 pandas 的 read_sql() 方法拿到 dataframe 结构的数据\nquestion_ids = pd.read_sql(sql_search,conn)\n# 关闭连接\nconn.close()\n\n情境C：python 脚本单方面向 mysql 发出指令，无需拿到数据如果已经存在某个表格，想要向该表格提交某条指令而无需返回数据时，比如：建表、对数据的增改删、对列的名称、列的属性修改等，代码如下。\nimport pymysql\n# 与 mysql 建立连接\nconn = pymysql.connect('localhost','username','password','databasename')\ncursor = conn.cursor()\n# sql 语句定义为一个字符串，插入一行数据\nsql_insert = 'INSERT INTO questions(q_id,q_title,q_description,q_keywords,q_people,q_pageview,time) VALUES( \"'\\\n                + str(quesition_id) + '\", \"' + str(one[0])+ '\", \"' + str(one[1]) + '\", \"' + str(one[2]) + '\", \"' \\\n                + str(one[3]) + '\", \"' + str(one[4]) + '\", \"' + str(datetime.datetime.now()) + '\");' \n# sql 语句定义为一个字符串，修改某个数据（另一个表格）\nsql_update = 'update topic_monitor SET is_title=\"1\" where question_id = \"' + str(quesition_id) + '\";'\n# 提交指令\ncursor.execute(sql_insert)\ncursor.execute(sql_update)\nconn.commit()\n\n# 插入一行数据；仅当该数据与表格已有数据不重复时才插入，否则就不会插入\nsql_insert = 'INSERT INTO `topic_monitor`(question_id,is_title,q_type,topic_id,time) SELECT \"'\\\n                    + x[0] + '\", \"0\", \"0\",\"'  + str(topic_id) + '\", \"'+ str(now) + '\" FROM DUAL WHERE NOT EXISTS(\\\n                    SELECT question_id FROM topic_monitor WHERE question_id = \"' + x[0] + '\")'\ncursor.execute(sql_insert)\nconn.commit()\n\n# 关闭连接\ncursor.close()\nconn.close()\n\n通过上面几种实用情况可以看到，python 与 mysql 实现交互的过程，通常分为：建立连接、把sql语句定义为字符串，提交指令、关闭连接。核心的技能在于 sql语句；除了定义sql语句字符串，其余3个处理都是固定的写法。\n我在最初一个月的实践中，最常出现的错误有：\n\n值的引用没有加上引号；\n符号错乱：多一个符号，少一个符号；\n值的类型不符合：不管 mysql 表格中该值是数，还是文本，在定义 sql 语句的字符串时，对每个值都需要转化为字符串；\n拷贝自己的代码时，忘记修改databasename。\n\n二、sql语句：搜索查询搜索是指在数据库的某个表格中查询符合特定条件的数据，并返回查询结果。其基本结构为：\nSELECT 【范围】FROM table_name 【条件】; 其中，范围是必须指定的，而条件可有可无。\n变量A：范围，是指返回查询结果的范围。返回该表格的所有字段，用 * 表达：\nSELECT * FROM table_name ;\n\n\n仅返回该表格的某个字段：\nSELECT column_name FROM table_name ;\n\n仅返回该表格的多个字段：\nSELECT column_name_1,column_name_3,column_name_3 FROM table_name ;\n\n\n仅返回符合条件的数据个数：\nSELECT count(*) FROM table_name ;\n\n\n变量B：条件是指，期望返回的数据满足哪些条件。不限定条件：\nSELECT * FROM table_name ;\n\n数值类：某个字段（数值类型的，比如double或者int），数值比较的操作符都可以使用比如，大于&gt;，小于&lt;，等于 = ，大于等于 &gt;= ，小于等于 &lt;= ：\n\nSELECT * FROM table_name WHERE num_column_name &gt;&#x3D; 1;\n\n文本类：某个字段（字符串类型的，比如char，text）：\nSELECT * FROM table_name WHERE str_column_name like “%your_str%”;\n\n\n也可以表达多个条件，and，or等可用于表达条件之间的关系：\nSELECT * FROM table_name WHERE num_column_name_1 &gt;&#x3D; 1 and  str_column_name like “%your_str%” ;\n\n\n三、sql语句：修改表属性横向的一整条数据，叫做行；竖向的一整条数据，叫作列。列的名字，叫做 column，这是通用的知识点。\n这段时间的实战中，我完全没有用到修改表的名称、重设index等知识点。最常用的，就是对列进行操作。每个列具备：列的名称、列的属性、列的数值。\n列的名称，需要留心不使用保留词。我的技巧是，尽量用一些_来表达该数据，比如 article_title，press_date 这种命名虽然稍长，但易读，也不会装上保留词。\n列的属性包括：类型，最大长度，是否为空，默认值，是否重复，是否为索引。通常，直接通过 pandas 的 pd.io.sql.to_sql() 一次性创建表格并保存数据时，列的默认属性并不合需求。要么提前自己定义表的结构，设置好每列属性；要么事后检查列属性，并逐列修改。所以，列的属性设定、修改是高频基础知识点。\n列的数值，即除了列名称外的、该列其它值。修改某个值，也是高频操作。不过我把这个知识点放到第四部分了。\n对列的名称、列的属性进行修改，主要的关键词都是 ALTER，具体又分为以下几种情况。\n情境A：新增一列。关键词 ADD在你所指定的 column_name 后面定义列的属性。\nALTER TABLE table_name ADD COLUMN column_name char(20);\n\n情境B：修改某列的名称。关键词 CHANGE在修改列名的同时也可以重新指定列的属性。\nALTER TABLE table_name CHANGE old_column_name new_column_name char(50);\n\n情境C：修改某列的属性。关键词是 MODIFYALTER TABLE table_name MODIFY column_name char(100);\n\n四、sql语句：数据的增改删通常提到数据库操作时，四字以蔽之：增删改查。\n\n查询，请看第二部分。关键词是 SELECT。\n对数据所依赖的属性的增、改，请看第三部分。关键词是 ALTER。\n数据的增加，在第一部分的数据交互中也给出实例，就不重复了。关键词是INSERT。\n数据的修改，关键词是 UPDATE。\n数据（甚至表格、库）的删除，关键词是DELETE。\n\n数据的修改，副关键词是 set 。\nUPDATE table_name SET columns_name &#x3D; new_value 【条件】;\n\n新数值如果是数值类型的，则直接写数值即可；如果是文本类型的，必须要加上双引号，比如，“your_new_value”。\n如果把【条件】部分不写，就相当于修改整列的值；想要修改特定范围，就要用到条件表达式，这和前面的查询部分是一致的，就不再重复。\n数据的删除，对于新手来说，是必须警惕的操作。因为一旦误操作，你将无力挽回。即便是职业程序员，也可能犯下无疑删库的惨剧。其基本语句为：\nDELETE FROM table_name【条件】;\n\n想要修改特定范围，就要用到条件表达式，这和前面的查询部分也是一致的，稍微啰嗦两句：不要对自己设定的条件太自信，最好先用搜索语句检查一下，然后再执行删除语句。\n\n删除单行数据：添加能唯一标识该行数据的条件语句。\n删除多行数据：添加能标识该范围的条件语句。\n删除整张表格：你是认真的吗？没有写错表格名字吧？！ 做这项操作前，必须确认清楚自己的意图，毕竟一旦发生，无可挽回。\n\n如果条件留空，将保留表结构，而删除所有数据行。想要删除整张表格，什么都不留下，则执行：\nDELETE TABLE table_name;\n\n俗称的“删库”就是删掉整个数据库，虽然实战中几乎不会用到，但作为新手经常手误，在练习阶段安全起见，最好还是专门创建一个 database 用于练手，练完直接删掉整个练习库：\nDELETE DATABASE database_name;\n\n如果简单总结下过去一个月，使用mysql的体验，那就是：除了mysql 的安装激活太麻烦，数据的增删改查比操作文本方便太多了！！完全值得容忍安装激活的麻烦。另外 mysql 常用语法确实简单、非常有规律。\n希望我的总结带给你帮助。鼓励我继续分享，那就请点个赞吧！\n","categories":["数据分析"],"tags":["转载","Python","MySQL"]},{"title":"互联网协议入门-阮一峰","url":"/2022/11/21/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%20-%20%E9%98%AE%E4%B8%80%E5%B3%B0%E7%9A%84%E7%BD%91%E7%BB%9C%E6%97%A5%E5%BF%97/","content":"我们每天使用互联网，你是否想过，它是如何实现的？\n全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？\n互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。\n下面就是我的学习笔记。因为这些协议实在太复杂、太庞大，我想整理一个简洁的框架，帮助自己从总体上把握它们。为了保证简单易懂，我做了大量的简化，有些地方并不全面和精确，但是应该能够说清楚互联网的原理。\n=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n互联网协议入门作者：阮一峰原文地址：https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html\n\n一、概述1.1 五层模型互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。\n用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。\n如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。\n\n如上图所示，最底下的一层叫做”实体层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。\n它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。\n1.2 层与协议每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。\n大家都遵守的规则，就叫做”协议”（protocol）。\n互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。\n二、实体层我们从最底下的一层开始。\n电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。\n\n这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送 0 和 1 的电信号。\n三、链接层3.1 定义单纯的 0 和 1 没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？\n这就是”链接层”的功能，它在”实体层”的上方，确定了 0 和 1 的分组方式。\n3.2 以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做“以太网”（Ethernet）的协议，占据了主导地位。\n以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。\n\n“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。\n“标头”的长度，固定为 18 字节。”数据”的长度，最短为 46 字节，最长为 1500 字节。因此，整个”帧”最短为 64 字节，最长为 1518 字节。如果数据很长，就必须分割成多个帧进行发送。\n3.3 MAC 地址上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？\n以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做 MAC 地址。\n\n每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。\n\n前 6 个十六进制数是厂商编号，后 6 个是该厂商的网卡流水号。有了 MAC 地址，就可以定位网卡和数据包的路径了。\n3.4 广播定义地址只是第一步，后面还有更多的步骤。\n首先，一块网卡怎么会知道另一块网卡的 MAC 地址？\n回答是有一种 ARP 协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的 MAC 地址，然后才能发送。\n其次，就算有了 MAC 地址，系统怎样才能把数据包准确送到接收方？\n回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。\n\n上图中，1 号计算机向 2 号计算机发送一个数据包，同一个子网络的 3 号、4 号、5 号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的 MAC 地址，然后与自身的 MAC 地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。\n有了数据包的定义、网卡的 MAC 地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。\n四、网络层4.1 网络层的由来以太网协议，依靠 MAC 地址发送数据。理论上，单单依靠 MAC 地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。\n但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。\n互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。\n\n因此，必须找到一种方法，能够区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC 地址本身无法做到这一点。它只与厂商有关，与所处网络无关。\n这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。\n于是，”网络层”出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。两种地址之间没有任何联系，MAC 地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。\n网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理 MAC 地址。\n4.2 IP 协议规定网络地址的协议，叫做 IP 协议。它所定义的地址，就被称为 IP 地址。\n目前，广泛采用的是 IP 协议第四版，简称 IPv4。这个版本规定，网络地址由 32 个二进制位组成。\n\n习惯上，我们用分成四段的十进制数表示 IP 地址，从 0.0.0.0 一直到 255.255.255.255。\n互联网上的每一台计算机，都会分配到一个 IP 地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP 地址 172.16.254.1，这是一个 32 位的地址，假定它的网络部分是前 24 位（172.16.254），那么主机部分就是后 8 位（最后的那个 1）。处于同一个子网络的电脑，它们 IP 地址的网络部分必定是相同的，也就是说 172.16.254.2 应该与 172.16.254.1 处在同一个子网络。\n但是，问题在于单单从 IP 地址，我们无法判断网络部分。还是以 172.16.254.1 为例，它的网络部分，到底是前 24 位，还是前 16 位，甚至前 28 位，从 IP 地址上是看不出来的。\n那么，怎样才能从 IP 地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。\n所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于 IP 地址，也是一个 32 位二进制数字，它的网络部分全部为 1，主机部分全部为 0。比如，IP 地址 172.16.254.1，如果已知网络部分是前 24 位，主机部分是后 8 位，那么子网络掩码就是 11111111.11111111.11111111.00000000，写成十进制就是 255.255.255.0。\n知道”子网掩码”，我们就能判断，任意两个 IP 地址是否处在同一个子网络。方法是将两个 IP 地址与子网掩码分别进行 AND 运算（两个数位都为 1，运算结果为 1，否则为 0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。\n比如，已知 IP 地址 172.16.254.1 和 172.16.254.233 的子网掩码都是 255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行 AND 运算，结果都是 172.16.254.0，因此它们在同一个子网络。\n总结一下，IP 协议的作用主要有两个，一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一个子网络。\n4.3 IP 数据包根据 IP 协议发送的数据，就叫做 IP 数据包。不难想象，其中必定包括 IP 地址信息。\n但是前面说过，以太网数据包只包含 MAC 地址，并没有 IP 地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？\n回答是不需要，我们可以把 IP 数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。\n具体来说，IP 数据包也分为”标头”和”数据”两个部分。\n\n“标头”部分主要包括版本、长度、IP 地址等信息，”数据”部分则是 IP 数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。\n\nIP 数据包的”标头”部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65,535 字节。因此，理论上，一个 IP 数据包的”数据”部分，最长为 65,515 字节。前面说过，以太网数据包的”数据”部分，最长只有 1500 字节。因此，如果 IP 数据包超过了 1500 字节，它就需要分割成几个以太网数据包，分开发送了。\n4.4 ARP 协议关于”网络层”，还有最后一点需要说明。\n因为 IP 数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的 MAC 地址，另一个是对方的 IP 地址。通常情况下，对方的 IP 地址是已知的（后文会解释），但是我们不知道它的 MAC 地址。\n所以，我们需要一种机制，能够从 IP 地址得到 MAC 地址。\n这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的 MAC 地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。\n第二种情况，如果两台主机在同一个子网络，那么我们可以用 ARP 协议，得到对方的 MAC 地址。ARP 协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的 IP 地址，在对方的 MAC 地址这一栏，填的是 FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出 IP 地址，与自身的 IP 地址进行比较。如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。\n总之，有了 ARP 协议之后，我们就可以得到同一个子网络内的主机 MAC 地址，可以把数据包发送到任意一台主机之上了。\n五、传输层5.1 传输层的由来有了 MAC 地址和 IP 地址，我们已经可以在互联网上任意两台主机上建立通信。\n接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？\n也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n“端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。0 到 1023 的端口被系统占用，用户只能选用大于 1023 的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。\n“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix 系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。\n5.2 UDP 协议现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做 UDP 协议，它的格式几乎就是在数据前面，加上端口号。\nUDP 数据包，也是由”标头”和”数据”两部分组成。\n\n“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个 UDP 数据包放入 IP 数据包的”数据”部分，而前面说过，IP 数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：\n\nUDP 数据包非常简单，”标头”部分一共只有 8 个字节，总长度不超过 65,535 字节，正好放进一个 IP 数据包。\n5.3 TCP 协议UDP 协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。\n为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的 UDP 协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。\n因此，TCP 协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。\nTCP 数据包和 UDP 数据包一样，都是内嵌在 IP 数据包的”数据”部分。TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割。\n六、应用层应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。\n“应用层”的作用，就是规定应用程序的数据格式。\n举例来说，TCP 协议可以为各种各样的程序传递数据，比如 Email、WWW、FTP 等等。那么，必须有不同协议规定电子邮件、网页、FTP 数据的格式，这些应用程序协议就构成了”应用层”。\n这是最高的一层，直接面对用户。它的数据就放在 TCP 数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。\n\n至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。\n（完）\n上一篇文章分析了互联网的总体构思，从下至上，每一层协议的设计思想。\n这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。\n=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n互联网协议入门（二）作者：阮一峰\n\n（接上文）\n七、一个小结先对前面的内容，做一个小结。\n我们已经知道，网络通信就是交换数据包。电脑 A 向电脑 B 发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：\n\n发送这个包，需要知道两个地址：\n\n* 对方的 MAC 地址\n* 对方的 IP 地址\n\n有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC 地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的 MAC 地址，必须通过网关（gateway）转发。\n\n上图中，1 号电脑要向 4 号电脑发送一个数据包。它先判断 4 号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关 A。网关 A 通过路由协议，发现 4 号电脑位于子网络 B，又把数据包发给网关 B，网关 B 再转发到 4 号电脑。\n1 号电脑把数据包发到网关 A，必须知道网关 A 的 MAC 地址。所以，数据包的目标地址，实际上分成两种情况：\n场景数据包地址同一个子网络对方的MAC地址，对方的IP地址非同一个子网络网关的MAC地址，对方的IP地址\n\n发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的 MAC 地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。\n八、用户的上网设置8.1 静态 IP 地址你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？\n\n通常你必须做一些设置。有时，管理员（或者 ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：\n\n* 本机的 IP 地址　　* 子网掩码　　* 网关的 IP 地址　　* DNS 的 IP 地址\n\n下图是 Windows 系统的设置窗口。\n\n这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的 IP 地址，所以这种情况被称作”静态 IP 地址上网”。\n但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的 IP 地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态 IP 地址上网”。\n8.2 动态 IP 地址所谓”动态 IP 地址”，指计算机开机后，会自动分配到一个 IP 地址，不用人为设定。它使用的协议叫做DHCP 协议。\n这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有 IP 地址，它叫做”DHCP 服务器”。新的计算机加入网络，必须向”DHCP 服务器”发送一个”DHCP 请求”数据包，申请 IP 地址和相关的网络参数。\n前面说过，如果两台计算机在同一个子网络，必须知道对方的 MAC 地址和 IP 地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？\nDHCP 协议做了一些巧妙的规定。\n8.3 DHCP 协议首先，它是一种应用层协议，建立在 UDP 协议之上，所以整个数据包是这样的：\n\n（1）最前面的”以太网标头”，设置发出方（本机）的 MAC 地址和接收方（DHCP 服务器）的 MAC 地址。前者就是本机网卡的 MAC 地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。\n（2）后面的”IP 标头”，设置发出方的 IP 地址和接收方的 IP 地址。这时，对于这两者，本机都不知道。于是，发出方的 IP 地址就设为 0.0.0.0，接收方的 IP 地址设为 255.255.255.255。\n（3）最后的”UDP 标头”，设置发出方的端口和接收方的端口。这一部分是 DHCP 协议规定好的，发出方是 68 端口，接收方是 67 端口。\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的 MAC 地址是 FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的 IP 地址，才能确定是不是发给自己的。当看到发出方 IP 地址是 0.0.0.0，接收方是 255.255.255.255，于是 DHCP 服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。\n接下来，DHCP 服务器读出这个包的数据内容，分配好 IP 地址，发送回去一个”DHCP 响应”数据包。这个响应包的结构也是类似的，以太网标头的 MAC 地址是双方的网卡地址，IP 标头的 IP 地址是 DHCP 服务器的 IP 地址（发出方）和 255.255.255.255（接收方），UDP 标头的端口是 67（发出方）和 68（接收方），分配给请求端的 IP 地址和本网络的具体参数则包含在 Data 部分。\n新加入的计算机收到这个响应包，于是就知道了自己的 IP 地址、子网掩码、网关地址、DNS 服务器等等参数。\n8.4 上网设置：小结这个部分，需要记住的就是一点：不管是”静态 IP 地址”还是”动态 IP 地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：\n\n* 本机的 IP 地址　　* 子网掩码　　* 网关的 IP 地址　　* DNS 的 IP 地址\n\n有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。\n九、一个实例：访问网页9.1 本机参数我们假定，经过上一节的步骤，用户设置好了自己的网络参数：\n\n* 本机的 IP 地址：192.168.1.100　　* 子网掩码：255.255.255.0　　* 网关的 IP 地址：192.168.1.1　　* DNS 的 IP 地址：8.8.8.8\n\n然后他打开浏览器，想要访问 Google，在地址栏输入了网址：www.google.com。\n\n这意味着，浏览器要向 Google 发送一个网页请求的数据包。\n9.2 DNS 协议我们知道，发送数据包，必须要知道对方的 IP 地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。\nDNS 协议可以帮助我们，将这个网址转换成 IP 地址。已知 DNS 服务器为 8.8.8.8，于是我们向这个地址发送一个 DNS 数据包（53 端口）。\n\n然后，DNS 服务器做出响应，告诉我们 Google 的 IP 地址是 172.194.72.105。于是，我们知道了对方的 IP 地址。\n9.3 子网掩码接下来，我们要判断，这个 IP 地址是不是在同一个子网络，这就要用到子网掩码。\n已知子网掩码是 255.255.255.0，本机用它对自己的 IP 地址 192.168.1.100，做一个二进制的 AND 运算（两个数位都为 1，结果为 1，否则为 0），计算结果为 192.168.1.0；然后对 Google 的 IP 地址 172.194.72.105 也做一个 AND 运算，计算结果为 172.194.72.0。这两个结果不相等，所以结论是，Google 与本机不在同一个子网络。\n因此，我们要向 Google 发送数据包，必须通过网关 192.168.1.1 转发，也就是说，接收方的 MAC 地址将是网关的 MAC 地址。\n9.4 应用层协议浏览网页用的是 HTTP 协议，它的整个数据包构造是这样的：\n\nHTTP 部分的内容，类似于下面这样：\n\nGET &#x2F; HTTP&#x2F;1.1　　 Host: www.google.com　　 Connection: keep-alive　　 User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1) ……　　 Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8　　 Accept-Encoding: gzip,deflate,sdch　　 Accept-Language: zh-CN,zh;q&#x3D;0.8　　 Accept-Charset: GBK,utf-8;q&#x3D;0.7,*;q&#x3D;0.3　　 Cookie: … …\n\n我们假定这个部分的长度为 4960 字节，它会被嵌在 TCP 数据包之中。\n9.5 TCP 协议TCP 数据包需要设置端口，接收方（Google）的 HTTP 端口默认是 80，发送方（本机）的端口是一个随机生成的 1024-65535 之间的整数，假定为 51775。\nTCP 数据包的标头长度为 20 字节，加上嵌入 HTTP 的数据包，总长度变为 4980 字节。\n9.6 IP 协议然后，TCP 数据包再嵌入 IP 数据包。IP 数据包需要设置双方的 IP 地址，这是已知的，发送方是 192.168.1.100（本机），接收方是 172.194.72.105（Google）。\nIP 数据包的标头长度为 20 字节，加上嵌入的 TCP 数据包，总长度变为 5000 字节。\n9.7 以太网协议最后，IP 数据包嵌入以太网数据包。以太网数据包需要设置双方的 MAC 地址，发送方为本机的网卡 MAC 地址，接收方为网关 192.168.1.1 的 MAC 地址（通过 ARP 协议得到）。\n以太网数据包的数据部分，最大长度为 1500 字节，而现在的 IP 数据包长度为 5000 字节。因此，IP 数据包必须分割成四个包。因为每个包都有自己的 IP 标头（20 字节），所以四个包的 IP 数据包的长度分别为 1500、1500、1500、560。\n\n9.8 服务器端响应经过多个网关的转发，Google 的服务器 172.194.72.105，收到了这四个以太网数据包。\n根据 IP 标头的序号，Google 将四个包拼起来，取出完整的 TCP 数据包，然后读出里面的”HTTP 请求”，接着做出”HTTP 响应”，再用 TCP 协议发回来。\n本机收到 HTTP 响应以后，就可以将网页显示出来，完成一次网络通信。\n\n这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。\n（完）\n","categories":["计算机"],"tags":["转载","互联网协议"]},{"title":"基于 Hexo 从零开始搭建个人博客","url":"/2022/11/11/%E5%9F%BA%E4%BA%8E%20Hexo%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"\n\n阅读本篇前，请先阅读前几篇文章：基于 Hexo 从零开始搭建个人博客（一）基于 Hexo 从零开始搭建个人博客（二）基于 Hexo 从零开始搭建个人博客（三）\n\n前言\n博客搭建过程遇到任何问题，优先在本页面搜索，检查是否已经有该配置教程。\n遇到问题可以优先在文章评论区留言，注意留言时请填写正确的邮箱以确保能收到站长的回复。\n实在解决不了的问题可添加博主 Wechat ，添加好友时请备注自己的姓名+专业，如 张三 计算机科学与技术。\n\nFront-matterFront-matter 是 markdown 文件最上方以---分隔的区域，用于指定个别档案的变数。\n\nPage Front-matter 用于页面配置\nPost Front-matter 用于文章页配置\n\n如果标注可选的参数，可根据自己需要添加，不用全部都写在 markdown 里\nPage Front-matter---title:date:updated:type:comments:description:keywords:top_img:mathjax:katex:aside:aplayer:highlight_shrink:---\n\n\n\n\n写法\n解释\n\n\n\ntitle\n【必需】页面标题\n\n\ndate\n【必需】页面创建日期\n\n\ntype\n【必需】标籤、分类和友情链接三个页面需要配置\n\n\nupdated\n【可选】页面更新日期\n\n\ndescription\n【可选】页面描述\n\n\nkeywords\n【可选】页面关键字\n\n\ncomments\n【可选】显示页面评论模块(默认 true)\n\n\ntop_img\n【可选】页面顶部图片\n\n\nmathjax\n【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)\n\n\nkatex\n【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\naplayer\n【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)\n\n\nPost Front-matter---title:date:updated:tags:categories:keywords:description:top_img:comments:cover:toc:toc_number:toc_style_simple:copyright:copyright_author:copyright_author_href:copyright_url:copyright_info:mathjax:katex:aplayer:highlight_shrink:aside:---\n\n\n\n\n写法\n解释\n\n\n\ntitle\n【必需】文章标题\n\n\ndate\n【必需】文章创建日期\n\n\nupdated\n【可选】文章更新日期\n\n\ntags\n【可选】文章标籤\n\n\ncategories\n【可选】文章分类\n\n\nkeywords\n【可选】文章关键字\n\n\ndescription\n【可选】文章描述\n\n\ntop_img\n【可选】文章顶部图片\n\n\ncover\n【可选】文章缩略图(如果没有设置 top_img,文章页顶部将显示缩略图，可设为 false&#x2F;图片地址&#x2F;留空)\n\n\ncomments\n【可选】显示文章评论模块(默认 true)\n\n\ntoc\n【可选】显示文章 TOC(默认为设置中 toc 的 enable 配置)\n\n\ntoc_number\n【可选】显示 toc_number(默认为设置中 toc 的 number 配置)\n\n\ntoc_style_simple\n【可选】显示 toc 简洁模式\n\n\ncopyright\n【可选】显示文章版权模块(默认为设置中 post_copyright 的 enable 配置)\n\n\ncopyright_author\n【可选】文章版权模块的文章作者\n\n\ncopyright_author_href\n【可选】文章版权模块的文章作者链接\n\n\ncopyright_url\n【可选】文章版权模块的文章连结链接\n\n\ncopyright_info\n【可选】文章版权模块的版权声明文字\n\n\nmathjax\n【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)\n\n\nkatex\n【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)\n\n\naplayer\n【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置\n\n\nhighlight_shrink\n【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)\n\n\naside\n【可选】显示侧边栏 (默认 true)\n\n\n\n注意：我的博客根目录路径为 【G:&#x2F;hexo-blog&#x2F;blog-demo】，下文所说的根目录都是此路径，将用[BlogRoot]代替。如果不清楚根目录路径，请回到教程 基于 Hexo 从零开始搭建个人博客（二），查看你执行hexo init xxx这条命令时所选择的路径，例如我选择的路径是【G:&#x2F;hexo-blog】，我的博客根目录即为【G:&#x2F;hexo-blog&#x2F;xxx】。\n\n标签页\n前往你的 Hexo 博客根目录，打开 cmd 命令窗口执行hexo new page tags。\n\n在【BlogRoot&#x2F;source&#x2F;】会生成一个含有index.md文件的tags文件夹。\n\n\n修改【BlogRoot&#x2F;source&#x2F;tags&#x2F;index.md】，添加type: &quot;tags&quot;。\n---title: tagsdate: 2022-05-29 21:42:56type: &quot;tags&quot;---\n\n分类页\n前往你的 Hexo 博客根目录，打开 cmd 命令窗口执行hexo new page categories。\n\n在【BlogRoot&#x2F;source&#x2F;】会生成一个含有index.md文件的categories文件夹。\n\n\n修改【BlogRoot&#x2F;source&#x2F;categories&#x2F;index.md】，添加type: &quot;categories&quot;。\n---title: categoriesdate: 2022-05-29 21:57:07type: &quot;categories&quot;---\n\n友情链接创建友情链接页面\n前往你的 Hexo 博客根目录，打开 cmd 命令窗口执行hexo new page link。\n\n在【BlogRoot&#x2F;source&#x2F;】会生成一个含有index.md文件的link文件夹。\n\n\n修改【BlogRoot&#x2F;source&#x2F;link&#x2F;index.md】，添加type: &quot;link&quot;。\n---title: linkdate: 2022-05-29 22:03:35type: &quot;link&quot;---\n\n友情链接页面添加友链信息前往 Hexo 博客目录（【BlogRoot&#x2F;source&#x2F;_data】）创建一个文件link.yml（如果沒有 _data 文件夹，请自行创建）。\n\n- class_name: 友情链接  class_desc: 那些人，那些事  link_list:    - name: 唐志远の博客      link: https:&#x2F;&#x2F;tzy1997.com&#x2F;      avatar: https:&#x2F;&#x2F;bu.dusays.com&#x2F;2022&#x2F;01&#x2F;14&#x2F;cd5ffd485f867.jpg      descr: 古今之成大事者，不惟有超世之才，亦必有坚忍不拔之志。- class_name: 网站  class_desc: 值得推荐的网站  link_list:    - name: Twitter      link: https:&#x2F;&#x2F;twitter.com&#x2F;      avatar: https:&#x2F;&#x2F;i.loli.net&#x2F;2020&#x2F;05&#x2F;14&#x2F;5VyHPQqR6LWF39a.png      descr: 社交分享平台\n\nclass_name和class_desc支持 html 格式，如不需要，也可以留空。\n如果你想设置成本站友链页的效果，请参考教程：基于 Butterfly 的外挂标签引入 。\n图库图库页面只是普通的页面，你只需要hexo new page xxxxx创建你的页面就行。\n然后使用标签外挂 galleryGroup，具体用法请查看对应的内容。\n&lt;div class&#x3D;&quot;gallery-group-main&quot;&gt;&#123;% galleryGroup &#39;壁纸&#39; &#39;收藏的一些壁纸&#39; &#39;&#x2F;Gallery&#x2F;wallpaper&#39; https:&#x2F;&#x2F;bu.dusays.com&#x2F;2021&#x2F;03&#x2F;06&#x2F;38a2c5cd8b44e.jpg %&#125;&#123;% galleryGroup &#39;漫威&#39; &#39;关于漫威的图片&#39; &#39;&#x2F;Gallery&#x2F;marvel&#39; https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;8t97aVlp4hgyBGu.jpg %&#125;&#123;% galleryGroup &#39;OH MY GIRL&#39; &#39;关于OH MY GIRL的图片&#39; &#39;&#x2F;Gallery&#x2F;ohmygirl&#39; https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;hOqbQ3BIwa6KWpo.jpg %&#125;&lt;&#x2F;div&gt;\n\n\n壁纸\n收藏的一些壁纸\n\n\n漫威\n关于漫威的图片\n\n\nOH MY GIRL\n关于 OH MY GIRL 的图片\n\n子页面子页面也是普通的页面，你只需要hexo new page xxxxx创建你的页面就行。\n然后使用标签外挂 gallery，具体用法请查看对应的内容。\n&#123;% gallery %&#125;![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;Fze9jchtnyJXMHN.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;ryLVePaqkYm4TEK.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;gEy5Zc1Ai6VuO4N.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;d6QHbytlSYO4FBG.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;6nepIJ1xTgufatZ.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;E7Jvr4eIPwUNmzq.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;mh19anwBSWIkGlH.jpg)![](https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;2tu9JC8ewpBFagv.jpg)&#123;% endgallery %&#125;\n\n如果你想要使用 /photo/ohmygirl 这样的链接显示你的图片内容\n你可以把创建好的 ohmygirl整个文件夹移到 photo文件夹里去\n404 页面主題內置了一个简单的 404 页面，可在设置中开放。\n\n如需本地预览，请访问 http://localhost:4000/404.html\n\nerror_404:  enable: true  subtitle: &quot;页面沒有找到&quot;  background:\n\n版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 唐志远の博客！\n打赏\n\n\nwechat\n\n\nalipay\n\n\n\n","categories":["博客"],"tags":["转载","hexo"]},{"title":"如何在Markdown里使用Echarts图表？","url":"/2022/11/14/%E5%A6%82%E4%BD%95%E5%9C%A8Markdown%E9%87%8C%E4%BD%BF%E7%94%A8Echarts%E5%9B%BE%E8%A1%A8%EF%BC%9F/","content":"使用HTML润色文本#519D9E颜色演示\nMarkdown里图片引入的三种方法\n第一种\n\n&lt;img src=\"https://images.unsplash.com/photo-1533257266619-e841826ce739?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=2369&amp;q=80\" \nalt=\"some_text\">\n\n\n\n\n第二种\n\n![图片引用方法二](&#x2F;image&#x2F;test.jpg)\n\n\n\n第三种\n\n&#123;% asset_img image&#x2F;test.png 图片引用方法一 %&#125;\n\n\n\n\n引入外部HTML - 使用iframe \n\n也可以是视频音乐等\n&lt;iframe src=\"//player.bilibili.com/player.html?aid=689464853&amp;bvid=BV1Wm4y1F7cs&amp;cid=871780885&amp;page=1\" width=\"100%\" height=\"600\" name=\"topFrame\" scrolling=\"yes\" noresize=\"noresize\" frameborder=\"0\" id=\"topFrame\"> &lt;/iframe>\n\n \n\n\n\n引入本地echasrts 方法一 使用iframe引入html文件\n\n\n引入本地echarts 方法二 直接写HTML和JS&lt;body style=\"height: 600px;;weight:100%: margin: 0;weight:100%\">\n    &lt;div id=\"container\" style=\"height: 400px;weight:100%\">&lt;/div>\n    &lt;script type=\"text/javascript\" src=\"https://fastly.jsdelivr.net/npm/echarts@5.4.0/dist/echarts.min.js\">&lt;/script>\n    &lt;script type=\"text/javascript\">\n        var dom = document.getElementById('container');\n        var myChart = echarts.init(dom, null, &#123;\n            renderer: 'canvas',\n            useDirtyRect: false\n        &#125;);\n        var app = &#123;&#125;;\n        var option;\n        option = &#123;\n            backgroundColor: '#2c343c',\n            title: &#123;\n                text: 'Customized Pie',\n                left: 'center',\n                top: 20,\n                textStyle: &#123;\n                    color: '#ccc'\n                &#125;\n            &#125;,\n            tooltip: &#123;\n                trigger: 'item'\n            &#125;,\n            visualMap: &#123;\n                show: false,\n                min: 80,\n                max: 600,\n                inRange: &#123;\n                    colorLightness: [0, 1]\n                &#125;\n            &#125;,\n            series: [&#123;\n                name: 'Access From',\n                type: 'pie',\n                radius: '55%',\n                center: ['50%', '50%'],\n                data: [&#123;\n                    value: 335,\n                    name: 'Direct'\n                &#125;, &#123;\n                    value: 310,\n                    name: 'Email'\n                &#125;, &#123;\n                    value: 274,\n                    name: 'Union Ads'\n                &#125;, &#123;\n                    value: 235,\n                    name: 'Video Ads'\n                &#125;, &#123;\n                    value: 400,\n                    name: 'Search Engine'\n                &#125;].sort(function(a, b) &#123;\n                    return a.value - b.value;\n                &#125;),\n                roseType: 'radius',\n                label: &#123;\n                    color: 'rgba(255, 255, 255, 0.3)'\n                &#125;,\n                labelLine: &#123;\n                    lineStyle: &#123;\n                        color: 'rgba(255, 255, 255, 0.3)'\n                    &#125;,\n                    smooth: 0.2,\n                    length: 10,\n                    length2: 20\n                &#125;,\n                itemStyle: &#123;\n                    color: '#c23531',\n                    shadowBlur: 200,\n                    shadowColor: 'rgba(0, 0, 0, 0.5)'\n                &#125;,\n                animationType: 'scale',\n                animationEasing: 'elasticOut',\n                animationDelay: function(idx) &#123;\n                    return Math.random() * 200;\n                &#125;\n            &#125;]\n        &#125;;\n        if (option &amp;&amp; typeof option === 'object') &#123;\n            myChart.setOption(option);\n        &#125;\n        window.addEventListener('resize', myChart.resize);\n    &lt;/script>\n&lt;/body>\n\n\n    \n    \n    \n        var dom = document.getElementById('container');\n        var myChart = echarts.init(dom, null, {\n            renderer: 'canvas',\n            useDirtyRect: false\n        });\n        var app = {};\n        var option;\n        option = {\n            backgroundColor: '#2c343c',\n            title: {\n                text: 'Customized Pie',\n                left: 'center',\n                top: 20,\n                textStyle: {\n                    color: '#ccc'\n                }\n            },\n            tooltip: {\n                trigger: 'item'\n            },\n            visualMap: {\n                show: false,\n                min: 80,\n                max: 600,\n                inRange: {\n                    colorLightness: [0, 1]\n                }\n            },\n            series: [{\n                name: 'Access From',\n                type: 'pie',\n                radius: '55%',\n                center: ['50%', '50%'],\n                data: [{\n                    value: 335,\n                    name: 'Direct'\n                }, {\n                    value: 310,\n                    name: 'Email'\n                }, {\n                    value: 274,\n                    name: 'Union Ads'\n                }, {\n                    value: 235,\n                    name: 'Video Ads'\n                }, {\n                    value: 400,\n                    name: 'Search Engine'\n                }].sort(function(a, b) {\n                    return a.value - b.value;\n                }),\n                roseType: 'radius',\n                label: {\n                    color: 'rgba(255, 255, 255, 0.3)'\n                },\n                labelLine: {\n                    lineStyle: {\n                        color: 'rgba(255, 255, 255, 0.3)'\n                    },\n                    smooth: 0.2,\n                    length: 10,\n                    length2: 20\n                },\n                itemStyle: {\n                    color: '#c23531',\n                    shadowBlur: 200,\n                    shadowColor: 'rgba(0, 0, 0, 0.5)'\n                },\n                animationType: 'scale',\n                animationEasing: 'elasticOut',\n                animationDelay: function(idx) {\n                    return Math.random() * 200;\n                }\n            }]\n        };\n        if (option && typeof option === 'object') {\n            myChart.setOption(option);\n        }\n        window.addEventListener('resize', myChart.resize);\n    \n\n\n\n引入本地echarts 方法三 使用tags语法引入JS代码通过jsDelivr的CDN引入echarts\n\n\n使用GL里的各种组件时需要添加，否则可不需要\n\n\n\n&#123;% echarts 400 '85%' %&#125; \n // 基于准备好的dom，初始化echarts实例\n    var myChart = echarts.init(document.getElementById('main'));\n    // 指定图表的配置项和数据\n    var option = &#123;\n        &#123; % echarts 400 '85%' %\n        &#125;\n        option = &#123;\n            title: &#123;\n                text: '堆叠区域图'\n            &#125;,\n            tooltip: &#123;\n                trigger: 'axis',\n                axisPointer: &#123;\n                    type: 'cross',\n                    label: &#123;\n                        backgroundColor: '#6a7985'\n                    &#125;\n                &#125;\n            &#125;,\n            legend: &#123;\n                data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎']\n            &#125;,\n            toolbox: &#123;\n                feature: &#123;\n                    saveAsImage: &#123;&#125;\n                &#125;\n            &#125;,\n            grid: &#123;\n                left: '3%',\n                right: '4%',\n                bottom: '3%',\n                containLabel: true\n            &#125;,\n            xAxis: [&#123;\n                type: 'category',\n                boundaryGap: false,\n                data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日']\n            &#125;],\n            yAxis: [&#123;\n                type: 'value'\n            &#125;],\n            series: [&#123;\n                name: '邮件营销',\n                type: 'line',\n                stack: '总量',\n                areaStyle: &#123;&#125;,\n                data: [120, 132, 101, 134, 90, 230, 210]\n            &#125;, &#123;\n                name: '联盟广告',\n                type: 'line',\n                stack: '总量',\n                areaStyle: &#123;&#125;,\n                data: [220, 182, 191, 234, 290, 330, 310]\n            &#125;, &#123;\n                name: '视频广告',\n                type: 'line',\n                stack: '总量',\n                areaStyle: &#123;&#125;,\n                data: [150, 232, 201, 154, 190, 330, 410]\n            &#125;, &#123;\n                name: '直接访问',\n                type: 'line',\n                stack: '总量',\n                areaStyle: &#123;&#125;,\n                data: [320, 332, 301, 334, 390, 330, 320]\n            &#125;, &#123;\n                name: '搜索引擎',\n                type: 'line',\n                stack: '总量',\n                label: &#123;\n                    normal: &#123;\n                        show: true,\n                        position: 'top'\n                    &#125;\n                &#125;,\n                areaStyle: &#123;&#125;,\n                data: [820, 932, 901, 934, 1290, 1330, 1320]\n            &#125;]\n        &#125;; &#123; % endecharts %\n        &#125;\n    &#125;;\n    // 使用刚指定的配置项和数据显示图表。\n    myChart.setOption(option);\n    // 刷新调整\n    window.onresize = function() &#123;\n        myChart.resize();\n    &#125;;\n&#123;% endecharts %&#125;\n\n\r\n\r\n        // 基于准备好的dom，初始化echarts实例\r\n        var myChart = echarts.init(document.getElementById('echarts6440'));\r\n\r\n        // 指定图表的配置项和数据\r\n        var option =  \noption = { title: { text: '堆叠区域图' }, tooltip: { trigger: 'axis', axisPointer: { type: 'cross', label: { backgroundColor: '#6a7985' } } }, legend: { data: ['邮件营销', '联盟广告', '视频广告', '直接访问', '搜索引擎'] }, toolbox: { feature: { saveAsImage: {} } }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis: [ { type: 'category', boundaryGap: false, data: ['周一', '周二', '周三', '周四', '周五', '周六', '周日'] } ], yAxis: [ { type: 'value' } ], series: [ { name: '邮件营销', type: 'line', stack: '总量', areaStyle: {}, data: [120, 132, 101, 134, 90, 230, 210] }, { name: '联盟广告', type: 'line', stack: '总量', areaStyle: {}, data: [220, 182, 191, 234, 290, 330, 310] }, { name: '视频广告', type: 'line', stack: '总量', areaStyle: {}, data: [150, 232, 201, 154, 190, 330, 410] }, { name: '直接访问', type: 'line', stack: '总量', areaStyle: {}, data: [320, 332, 301, 334, 390, 330, 320] }, { name: '搜索引擎', type: 'line', stack: '总量', label: { normal: { show: true, position: 'top' } }, areaStyle: {}, data: [820, 932, 901, 934, 1290, 1330, 1320] } ] };\r\n\r\n        // 使用刚指定的配置项和数据显示图表。\r\n        myChart.setOption(option);\r\n\n\n\r\n\r\n        // 基于准备好的dom，初始化echarts实例\r\n        var myChart = echarts.init(document.getElementById('echarts2713'));\r\n\r\n        // 指定图表的配置项和数据\r\n        var option =  \noption = { xAxis: { type: 'category', boundaryGap: false }, yAxis: { type: 'value', boundaryGap: [0, '30%'] }, visualMap: { type: 'piecewise', show: false, dimension: 0, seriesIndex: 0, pieces: [{ gt: 1, lt: 3, color: 'rgba(0, 180, 0, 0.5)' }, { gt: 5, lt: 7, color: 'rgba(0, 180, 0, 0.5)' }] }, series: [ { type: 'line', smooth: 0.6, symbol: 'none', lineStyle: { color: 'green', width: 5 }, markLine: { symbol: ['none', 'none'], label: {show: false}, data: [ {xAxis: 1}, {xAxis: 3}, {xAxis: 5}, {xAxis: 7} ] }, areaStyle: {}, data: [ ['2019-10-10', 200], ['2019-10-11', 400], ['2019-10-12', 650], ['2019-10-13', 500], ['2019-10-14', 250], ['2019-10-15', 300], ['2019-10-16', 450], ['2019-10-17', 300], ['2019-10-18', 100] ] } ] }; \r\n\r\n        // 使用刚指定的配置项和数据显示图表。\r\n        myChart.setOption(option);\r\n\n\n\n\r\n\r\n        // 基于准备好的dom，初始化echarts实例\r\n        var myChart = echarts.init(document.getElementById('echarts6394'));\r\n\r\n        // 指定图表的配置项和数据\r\n        var option = option = {\n           backgroundColor: '#2c343c',\n           title: {\n               text: 'Customized Pie',\n               left: 'center',\n               top: 20,\n               textStyle: {\n                   color: '#ccc'\n               }\n           },\n           tooltip: {\n               trigger: 'item'\n           },\n           visualMap: {\n               show: false,\n               min: 80,\n               max: 600,\n               inRange: {\n                   colorLightness: [0, 1]\n               }\n           },\n           series: [{\n               name: 'Access From',\n               type: 'pie',\n               radius: '55%',\n               center: ['50%', '50%'],\n               data: [{\n                   value: 335,\n                   name: 'Direct'\n               }, {\n                   value: 310,\n                   name: 'Email'\n               }, {\n                   value: 274,\n                   name: 'Union Ads'\n               }, {\n                   value: 235,\n                   name: 'Video Ads'\n               }, {\n                   value: 400,\n                   name: 'Search Engine'\n               }].sort(function(a, b) {\n                   return a.value - b.value;\n               }),\n               roseType: 'radius',\n               label: {\n                   color: 'rgba(255, 255, 255, 0.3)'\n               },\n               labelLine: {\n                   lineStyle: {\n                       color: 'rgba(255, 255, 255, 0.3)'\n                   },\n                   smooth: 0.2,\n                   length: 10,\n                   length2: 20\n               },\n               itemStyle: {\n                   color: '#c23531',\n                   shadowBlur: 200,\n                   shadowColor: 'rgba(0, 0, 0, 0.5)'\n               },\n               animationType: 'scale',\n               animationEasing: 'elasticOut',\n               animationDelay: function(idx) {\n                   return Math.random() * 200;\n               }\n           }]\n       };\r\n\r\n        // 使用刚指定的配置项和数据显示图表。\r\n        myChart.setOption(option);\r\n\n\n\n\n\n参考：https://hexo.fluid-dev.com/posts/hexo-echarts/#https://pxxyyz.com/posts/html-in-Fluid/#https://echarts.apache.org/examples/zh/index.html#chart-type-bar\n\n","categories":["博客"],"tags":["原创","markdown"]},{"title":"如何让SQL提高一个台阶？","url":"/2022/11/11/%E5%A6%82%E4%BD%95%E8%AE%A9SQL%E6%8F%90%E9%AB%98%E4%B8%80%E4%B8%AA%E5%8F%B0%E9%98%B6%EF%BC%9F/","content":"\nMySQl 专栏持续更新 不说晦涩难懂的东西 尽量输出容易理解 和 使用的 SQL 技巧 和 初中级开发不是很常用的但很有用的知识\n欢迎查看 👉🏻👉🏻👉🏻SQL 专栏 查漏补缺 指教一二\n\n每一次写博客对技术都会有更深入的理解 积少成多 百天计划我也想看看自己有多少成长 祝君好运 工作顺利\n\n前言SQL 写不好 加班少不了 日常工作中 SQL 是必不可少的一项技术 但是很多人不会过多的去关注 SQL 问题 一是数据量小 二是没有意识到索引的重要性 本文主要是整理 SQL 失效场景 如果里面的细节你都知道 那你一定是学习能力比较好的人 膜拜 写完这篇文章 我感觉自己之前知道的真的是 “目录” 没有明白其中的内容 如果你能跟着节奏看完文章 一定会有收获 至少我写完感觉思维通透很多 以后百分之九十的 SQl 索引问题 和 面试这方面问题都能拿捏两\n文章 字数 四千余字 观看时长十分钟 练习时长两个半小时\n基础数据准备准备一个数据表作为 数据演示 这里面一共 创建了三个索引\n\n联合索引 sname, s_code, address\n主键索引 id\n普通索引 height\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS &#x3D; 0;\n\n-- ----------------------------\n-- Table structure for student\n-- ----------------------------\nDROP TABLE IF EXISTS &#96;student&#96;;\nCREATE TABLE &#96;student&#96;  (\n  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,\n  &#96;sname&#96; varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  &#96;s_code&#96; int(100) NULL DEFAULT NULL,\n  &#96;address&#96; varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  &#96;height&#96; double NULL DEFAULT NULL,\n  &#96;classid&#96; int(11) NULL DEFAULT NULL,\n  &#96;create_time&#96; datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0),\n  PRIMARY KEY (&#96;id&#96;) USING BTREE,\n  INDEX &#96;普通索引&#96;(&#96;height&#96;) USING BTREE,\n  INDEX &#96;联合索引&#96;(&#96;sname&#96;, &#96;s_code&#96;, &#96;address&#96;) USING BTREE\n) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 5 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;\n\n-- ----------------------------\n-- Records of student\n-- ----------------------------\nINSERT INTO &#96;student&#96; VALUES (1, &#39;学生1&#39;, 1, &#39;上海&#39;, 170, 1, &#39;2022-11-02 20:44:14&#39;);\nINSERT INTO &#96;student&#96; VALUES (2, &#39;学生2&#39;, 2, &#39;北京&#39;, 180, 2, &#39;2022-11-02 20:44:16&#39;);\nINSERT INTO &#96;student&#96; VALUES (3, &#39;变成派大星&#39;, 3, &#39;京东&#39;, 185, 3, &#39;2022-11-02 20:44:19&#39;);\nINSERT INTO &#96;student&#96; VALUES (4, &#39;学生4&#39;, 4, &#39;联通&#39;, 190, 4, &#39;2022-11-02 20:44:25&#39;);\n\n正文上面的 SQL 我们已经创建好基本的数据 在验证之前 先带着几个问题\n\n我们先从上往下进行验证\n最左匹配原则写在前面：我很早之前就听说过数据库的最左匹配原则，当时是通过各大博客论坛了解的，但是这些博客的局限性在于它们对最左匹配原则的描述就像一些数学定义一样，往往都是列出 123 点，满足这 123 点就能匹配上索引，否则就不能。 最左匹配原则就是指在联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，我们上面建立了联合索引 可以用来测试最左匹配原则 sname, s_code, address\n请看下面 SQL 语句 进行思考 是否会走索引\n-- 联合索引 sname,s_code,address\n\n1、select create_time from student where sname &#x3D; &quot;变成派大星&quot;  -- 会走索引吗？\n\n2、select create_time from student where s_code &#x3D; 1   -- 会走索引吗？\n\n3、select create_time from student where address &#x3D; &quot;上海&quot;  -- 会走索引吗？\n\n4、select create_time from student where address &#x3D; &quot;上海&quot; and s_code &#x3D; 1 -- 会走索引吗？\n\n5、select create_time from student where address &#x3D; &quot;上海&quot; and sname &#x3D; &quot;变成派大星&quot;  -- 会走索引吗？\n\n6、select create_time from student where sname &#x3D; &quot;变成派大星&quot; and address &#x3D; &quot;上海&quot;  -- 会走索引吗？\n\n7、select create_time from student where sname &#x3D; &quot;变成派大星&quot; and s_code &#x3D; 1 and address &#x3D; &quot;上海&quot;  -- 会走索引吗？\n\n凭你的经验 哪些会使用到索引呢 ？ 可以先思考一下 在心中记下数字\n\n走索引例子\nEXPLAIN  select create_time from student where sname &#x3D; &quot;变成派大星&quot;  -- 会走索引吗？\n\n\n未走索引例子\nEXPLAIN select create_time from student where address &#x3D; &quot;上海&quot; and s_code &#x3D; 1 -- 会走索引吗？\n\n走的全表扫描 rows &#x3D; 4  如果不知道EXPLAIN 是什么的 或者看不懂分析出来的数据的话 建议去看看另一篇文章分析命令 EXPLAIN 超详解\n如果你内心的答案没有全部说对就接着往下看\n最左匹配原则顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。例如：s_code &#x3D; 2 如果建立(sname, s_code)顺序的索引，是匹配不到(sname, s_code)索引的;\n但是如果查询条件是 sname &#x3D; “变成派大星” and s_code &#x3D; 2 或者 a&#x3D;1(又或者是 s_code &#x3D; 2 and sname &#x3D; “变成派大星” )就可以，因为优化器会自动调整sname, s_code的顺序。再比如 sname &#x3D; “变成派大星” and s_code &gt; 1 and address &#x3D; “上海” address是用不到索引的，因为 s_code 字段是一个范围查询，它之后的字段会停止匹配。\n不带范围查询 索引使用类型 \n带范围使用类型\n\n根据上一篇文章的讲解 可以明白 ref 和 range 的含义 级别还是相差很多的\n\n思考为什么左链接一定要遵循最左缀原则呢？\n验证看过一个比较好玩的回答\n\n你可以认为联合索引是闯关游戏的设计例如你这个联合索引是 state&#x2F;city&#x2F;zipCode那么 state 就是第一关 city 是第二关， zipCode 就是第三关你必须匹配了第一关，才能匹配第二关，匹配了第一关和第二关，才能匹配第三关\n\n这样描述不算完全准确 但是确实是这种思想\n要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗 B+树，那么联合索引的底层也就是一颗 B+树，只不过联合索引的 B+树节点中存储的是键值。由于构建一棵 B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建 文字比较抽象 我们看一下\n加入我们建立 A,B 联合索引 他们在底层储存是什么样子呢？\n\n橙色代表字段 A\n浅绿色 代表字段 B\n\n图解： \n我们可以看出几个特点\n\nA 是有顺序的 1，1，2，2，3，4\nB 是没有顺序的 1，2，1，4，1，2 这个是散列的\n如果 A 是等值的时候 B 是有序的 例如 （1，1），（1，2） 这里的 B 有序的 （2，1）,(2,4) B 也是有序的\n\n这里应该就能看出 如果没有 A 的支持 B 的索引是散列的 不是连续的\n再细致一点 我们重新创建一个表\nDROP TABLE IF EXISTS &#96;leftaffix&#96;;\n\nCREATE TABLE &#96;leftaffix&#96;  (\n\n  &#96;a&#96; int(11) NOT NULL AUTO_INCREMENT,\n\n  &#96;b&#96; int(11) NULL DEFAULT NULL,\n\n  &#96;c&#96; int(11) NULL DEFAULT NULL,\n\n  &#96;d&#96; int(11) NULL DEFAULT NULL,\n\n  &#96;e&#96; varchar(11) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n\n  PRIMARY KEY (&#96;a&#96;) USING BTREE,\n\n  INDEX &#96;联合索引&#96;(&#96;b&#96;, &#96;c&#96;, &#96;d&#96;) USING BTREE\n\n) ENGINE &#x3D; InnoDB AUTO_INCREMENT &#x3D; 8 CHARACTER SET &#x3D; utf8 COLLATE &#x3D; utf8_general_ci ROW_FORMAT &#x3D; Dynamic;\n\n-- ----------------------------\n-- Records of leftaffix\n-- ----------------------------\nINSERT INTO &#96;leftaffix&#96; VALUES (1, 1, 1, 1, &#39;1&#39;);\n\nINSERT INTO &#96;leftaffix&#96; VALUES (2, 2, 2, 2, &#39;2&#39;);\n\nINSERT INTO &#96;leftaffix&#96; VALUES (3, 3, 2, 2, &#39;3&#39;);\n\nINSERT INTO &#96;leftaffix&#96; VALUES (4, 3, 1, 1, &#39;4&#39;);\n\nINSERT INTO &#96;leftaffix&#96; VALUES (5, 2, 3, 5, &#39;5&#39;);\n\nINSERT INTO &#96;leftaffix&#96; VALUES (6, 6, 4, 4, &#39;6&#39;);\n\nINSERT INTO &#96;leftaffix&#96; VALUES (7, 8, 8, 8, &#39;7&#39;);\nSET FOREIGN_KEY_CHECKS &#x3D; 1;\n\n\n\n在创建索引树的时候会对数据进行排序 根据最左缀原则 会先通过 B 进行排序 也就是 如果出现值相同就 根据 C 排序 如果 C 相同就根据 D 排序 排好顺序之后就是如下图：\n\n\n\n索引的生成就会根据图二的顺序进行生成 我们看一下 生成后的树状数据是什么样子\n\n\n\n解释一些这个树状图 首先根据图二的排序 我们知道顺序 是 1111a 2222b 所以 在第三层 我们可以看到 1111a 在第一层 2222b 在第二层 因为 111 &lt; 222 所以 111 进入第二层 然后得出第一层\n\n\n简化一下就是这个样子\n但是这种顺序是相对的。这是因为 MySQL 创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以 B&#x3D;2 这种查询条件没有办法利用索引。\n看到这里还可以明白一个道理 为什么我们建立索引的时候不推荐建立在经常改变的字段 因为这样的话我们的索引结构就要跟着你的改变而改动 所以很消耗性能\n小总结前提 如果创建 b,c,d 联合索引面\n\n如果 我 where 后面的条件是c = 1 and d = 1为什么不能走索引呢 如果没有 b 的话 你查询的值相当于 *11 我们都知道*是所有的意思也就是我能匹配到所有的数据\n如果 我 where 后面是 b = 1 and d =1 为什么会走索引呢？ 你等于查询的数据是 1*1 我可以通过前面 1 进行索引匹配 所以就可以走索引\n最左缀匹配原则的最重要的就是 第一个字段\n\n我们接着看下一个失效场景\nselect *思考首先提出问题 select * 一定会索引失效吗？\n解释如果你的心里答案是 会失效那就接着往下看\n\n细心的同学能够发现 即便我使用了 select * 依然会走索引 这是为什么呢？\n首先我们在上一个验证中创建了联合索引 我们使用 B&#x3D;1 会走索引\n\n\n也就是 Select * 在一些情况下是会走索引的 那么什么时候不会走索引呢\n\n经过测试 在查询返回结果集大约总数据的 25%就不会走索引了 进而全表扫描 这里也有一个知识点 也就是为什么范围查找会索引失效的原因\n\n\n上图就是索引失效的情况\n范围查找也不是一定会索引失效 下面情况就会索引生效就是 级别低 生效的原因是因为缩小了范围\n\n小总结\nselect * 只有在返回结果集数量大于总结果集的 25% 就会造成索引失效 如果小于 不会造成索引失效但是会降低索引的效率\n范围查找有概率索引失效但是 但是在特定的情况下会生效 范围小就会使用 也可以理解为 返回结果集小就会使用索引\n\n使用函数使用在 Select 后面使用函数可以使用索引 但是下面这种做法就不能\n\n\n因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。\n不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\n这种写法我没使用过 感觉情况比较少 也比较容易注意到这种写法\n计算操作这个情况和上面一样 之所以会导致索引失效是因为改变了索引原来的值 在树中找不到对应的数据只能全表扫描\n 因为索引保存的是索引字段的原始值，而不是 b - 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。\n下面这种计算方式就会使用索引\n\nJava 比较熟悉的可能会有点疑问，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 b - 1 &#x3D; 6 变成 b &#x3D; 6 - 1。 是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。\n小总结总而言之 言而总之 只要是影响到索引列的值 索引就是失效\nLike %这个真的是难受哦 因为经常使用这个 所以还是要小心点 在看为什么失效之前 我们先看一下 Like % 的解释\n\n%百分号通配符: 表示任何字符出现任意次数(可以是 0 次).\n_下划线通配符: 表示只能匹配单个字符,不能多也不能少,就是一个字符.\nlike 操作符: LIKE 作用是指示 mysql 后面的搜索模式是利用通配符而不是直接相等匹配进行比较.\n\n注意: 如果在使用 like 操作符时,后面的没有使用通用匹配符效果是和&#x3D;一致的,\nSELECT * FROM products WHERE products.prod_name like &#39;1000&#39;;\n\n2.匹配包含”Li”的记录(包括记录”Li”) :\nSELECT* FROM products WHERE products.prod_name like &#39;%Li%&#39;;\n\n3.匹配以”Li”结尾的记录(包括记录”Li”,不包括记录”Li “,也就是 Li 后面有空格的记录,这里需要注意)\nSELECT * FROM products WHERE products.prod_name like &#39;%Li&#39;;\n\n在左不走 在右走\n右： 虽然走 但是索引级别比较低主要是模糊查询 范围比较大 所以索引级别就比较低 \n左： 这个范围非常大 所以没有使用索引的必要了 这个可能不是很好优化 还好不是一直拼接上面的\n\n小总结索引的时候和查询范围关系也很大 范围过大造成索引没有意义从而失效的情况也不少\n使用 Or 导致索引失效这个原因就更简单了\n在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效 举个例子，比如下面的查询语句，b 是主键，e 是普通列，从执行计划的结果看，是走了全表扫描。\n\n优化这个的优化方式就是 在 Or 的时候两边都加上索引\n就会使用索引 避免全表扫描 \nin 使用不当首先使用 In 不是一定会造成全表扫描的 IN 肯定会走索引，但是当 IN 的取值范围较大时会导致索引失效，走全表扫描\n\n\nin 在结果集 大于 30%的时候索引失效\nnot in 和 In 的失效场景相同order By 这一个主要是 Mysql 自身优化的问题 我们都知道 OrderBy 是排序 那就代表我需要对数据进行排序 如果我走索引 索引是排好序的 但是我需要回表 消耗时间 另一种 我直接全表扫描排序 不用回表 也就是\n\n走索引 + 回表\n不走索引 直接全表扫描\n\nMysql 认为直接全表扫面的速度比 回表的速度快所以就直接走索引了 在 Order By 的情况下 走全表扫描反而是更好的选择\n子查询会走索引吗答案是会 但是使用不好就不会\n大总结\n\n如果你是直接跳到这里 看看文章有多长 建议收藏\n如果你一步步看到这里 感觉有点帮助 赞赞来一个\n如果感觉文章有问题 建议评论区指出 会修正\n\n周五愉快 文章完结 🥰\n持续更新 SQL 相关系列 可追更 不可催更\n\n本文正在参加「技术专题 19 期 漫谈数据库技术」活动\n","categories":["数据分析"],"tags":["转载","SQL"]},{"title":"技术导航","url":"/2022/11/16/%E6%8A%80%E6%9C%AF%E5%AF%BC%E8%88%AA/","content":"👇 Java语言相关\nJava 学习路线: https://www.pdai.tech/md/outline/x-outline.html\nJava 入门教程: https://www.liaoxuefeng.com/wiki/1252599548343744\nJvm 手册: http://www.ityouknow.com/java.html\nDubbo手册: https://dubbo.apache.org/zh/docs/)\nNetty: https://netty.io/wiki/index.html)\nJava NIO 教程: http://www.ityouknow.com/java.html\nSpring 实战: https://potoyang.gitbook.io/spring-in-action-v5/\nSpring Boot 手册: http://www.ityouknow.com/spring-boot.html\nSpring Cloud 手册: http://www.ityouknow.com/spring-cloud.html\nSpring Data JPA - 参考文档: https://www.springcloud.cc/spring-data-jpa.html\nApache Shiro 中文文档: https://www.docs4dev.com/docs/zh/apache-shiro/1.5.3/reference/introduction.html\nNetty 4.x 用户指南: https://waylau.com/netty-4-user-guide/\nMyBatis中文文档: https://mybatis.org/mybatis-3/zh/index.html\nTomcat 8 权威指南: https://wiki.jikexueyuan.com/project/tomcat/\n\n👉 Python语言相关\nPython 零基础入门: http://www.ityouknow.com/python.html\nPython CookBook 中文版: https://www.kancloud.cn/kancloud/python3-cookbook\nPython进阶: https://docs.pythontab.com/interpy/\nDjango 教程: https://docs.djangoproject.com/zh-hans/3.2//\nFlask 教程: http://docs.jinkan.org/docs/flask/quickstart.html#quickstart\nScrapy 教程: https://www.osgeo.cn/scrapy/index.html\n\n🖐 其他编程语言文档\nC 语言教程: https://www.nowcoder.com/tutorial/10002/8f7c3e0e7efd441d8f7c9c8d43c2a0f4\nC++ 学习教程（中）: https://www.w3cschool.cn/cpp/\nLaravel 8 中文教程: https://learnku.com/docs/laravel/8.x/releases/9351\nGo 语言教程: http://www.topgoer.com/\nGo Web 编程: https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md\nPHP 教程: https://phpbestpractices.justjavac.com/#\nPHP 开发者实践: https://ryancao.gitbooks.io/php-developer-prepares/content/\nThinkPHP 教程: https://www.kancloud.cn/agdholo/thinkphp\nVisual Basic 教程: https://docs.microsoft.com/zh-cn/visualstudio/get-started/visual-basic/?view=vs-2019\nR语言教程: https://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/intro.html\nSwift 教程: https://swift.bootcss.com/\nRuby 教程: https://www.ruby-lang.org/zh_cn/documentation/\n\n👨开发工具必备\nGit 学习手册: https://git-scm.com/book/zh/v2\nGit互动教程: https://learngitbranching.js.org/?locale=zh_CN\nSQL 教程: https://www.kancloud.cn/wizardforcel/w3school-sql/93915\nLeetCode 刷题手册: https://books.halfrost.com/leetcode/ChapterOne/\nNginx 极简教程: https://dunwu.github.io/nginx-tutorial/#/nginx-quickstart\n图说设计模式: https://design-patterns.readthedocs.io/zh_CN/latest/index.html\nJSON 手册: http://www.dingding.team/book/json/\nIDEA 使用教程: https://github.com/judasn/IntelliJ-IDEA-Tutorial\nDocker 教程: https://yeasy.gitbook.io/docker_practice/\n\n👩大数据相关\nApache 教程: https://www.yiibai.com/apache_http/\nhadoop 文档: https://hadoop.apache.org/docs/r1.0.4/cn/index.html\nHive 文档: https://hive.apache.org/\nHBase 文档: https://blogs.apache.org/hbase/\nImpala 文档: https://impala.apache.org/\nOozie 调度框架文档: https://oozie.apache.org/\nApache Sentry: https://sentry.apache.org/\nZooKeeper: https://github.com/apache/zookeeper/\nSpark 官方文档: https://spark.apache.org/\nSpark 教程: https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/\nFlink 官方文档: https://flink.apache.org/\n\n👨存储相关\nRedis 中文教程: https://www.redis.com.cn/tutorial.html\nmemcached 教程: https://www.twle.cn/l/yufei/memcached/memcached-basic-index.html\nMysql 简单教程: https://segmentfault.com/a/1190000006876419\nMongoDB 教程: https://www.mongodb.org.cn/tutorial/\nElasticsearch 教程: https://www.elastic.co/guide/cn/elasticsearch/guide/current/getting-started.html\nOpenResty 最佳实践: https://moonbingbing.gitbooks.io/openresty-best-practices/content/\n\n🙆Linux 相关\n鸟哥的 Linux 私房菜: http://cn.linux.vbird.org/linux_basic/linux_basic.php\nBash Shell 教程: https://wangdoc.com/bash/intro.html\nShell 教程: http://billie66.github.io/TLCL/book/index.html\nHTTP 2.0 翻译: https://yuedu.baidu.com/ebook/478d1a62376baf1ffc4fad99?pn=1###\n\n🤦移动端手册\n鸿蒙OS 手册: https://developer.harmonyos.com/cn/documentation/\nAndroid 手册: https://developer.android.com/guide?hl=zh-cn\nIOS 手册: https://developer.apple.com/cn/documentation/\n微信小程序手册: https://developers.weixin.qq.com/miniprogram/dev/framework/\nReact Native 手册: https://reactnative.cn/docs/getting-started\nFlutter 手册: https://flutter.cn/docs\nMUI 手册: https://dev.dcloud.net.cn/mui/\nWeUI 手册: https://weui.io/\nVUX 手册: https://doc.vux.li/zh-CN/\nFrozenUI 手册: http://frozenui.github.io/getting-started\nCube-UI 手册: https://didi.github.io/cube-ui/#/zh-CN/docs/introduction\n\n💇前端手册\nHtml 教程: https://developer.mozilla.org/zh-CN/docs/learn/HTML\nJS 教程: https://developer.mozilla.org/zh-CN/docs/learn/HTML\nCSS参考手册: http://css.doyoe.com/\njQuery 操作手册: https://www.jquery123.com/\nBootstrap 操作手册: https://v4.bootcss.com/docs/getting-started/introduction/\nVue.js手册: https://v3.cn.vuejs.org/guide/introduction.html\nReact教程: https://zh-hans.reactjs.org/tutorial/tutorial.html\nAngularJS教程: https://www.angularjs.net.cn/tutorial/\n七天学会NodeJS: http://nqdeng.github.io/7-days-nodejs/\nVue cli 教程: https://cli.vuejs.org/zh/guide/\nAngular 手册: https://angular.cn/docs\nES6 教程: https://es6.ruanyifeng.com/\n\n👇转换工具\n时间戳转换: https://tool.lu/timestamp/\n图片base64编码: https://tool.lu/base64image/\n进制转换: https://tool.lu/hexconvert/\n\n🤠代码格式化工具\nSQL格式转换: https://tool.lu/sql/\nJson格式转换: https://tool.lu/json/\nJava格式化: https://tool.oschina.net/codeformat/java\nPHP格式化: https://tool.lu/php/\nPython格式化: https://tool.lu/pyc/\nHtml格式转换: https://tool.chinaz.com/tools/jsformat.aspx\nJs格式转换: https://tool.chinaz.com/tools/jsformat.aspx\nCSS格式转换: https://tool.chinaz.com/Tools/CssFormat.aspx\nXml格式转换: https://tool.lu/xml/\n\n😍常用工具\n在线文本对比: https://text-compare.com/zh-hans/\n正则表达式测试: https://tool.oschina.net/regex/\nSQL工具: https://tool.lu/sql/\n加密解密: https://tool.oschina.net/encrypt\nCron查询: https://www.matools.com/cron/\n二维码制作工具: https://cli.im/\nIP地址查询: https://tool.lu/ip/\n下载链接转换工具: https://tool.lu/urlconvert/\ncurl命令转代码: https://tool.lu/curl/\n字数统计: https://www.eteste.com/\n数字大写转换器: https://tool.gaodun.com/rmb.html\n颜色转化器: https://www.sioe.cn/yingyong/yanse-rgb-16/\n在线代码测试: https://tool.lu/coderunner/\n\n🤣技术社区\n博客园: https://www.cnblogs.com\n掘金: https://juejin.im\n开源中国: https://www.oschina.net\nInfoQ: https://xie.infoq.cn\n51CTO: https://www.51cto.com\n腾讯云社区: https://cloud.tencent.com/developer\n阿里云社区: https://developer.aliyun.com\n华为云社区: https://bbs.huaweicloud.com/community/\nSF思否: https://segmentfault.com\nCSDN: https://www.csdn.net\nGolang中文社区: https://studygolang.com\n开发者头条: https://toutiao.io\nStackOverflow: https://stackoverflow.com\nChinaUnix: http://www.chinaunix.net\n简书: https://www.jianshu.com\n\n🤡开发工具大全\nIntelliJ IDEA: https://www.jetbrains.com/idea\nVS Code: https://code.visualstudio.com\nMac破解应用: https://xclient.info\nIDEA 破解: http://itmooc.tech\nEclipse: https://www.eclipse.org/downloads\nPycharm: https://www.jetbrains.com/pycharm\nSublime Text: https://www.sublimetext.com\nNodepad++: https://notepad-plus.en.softonic.com\nEditPlus: https://www.editplus.com/download.html\natom: https://atom.io\nWebStorm: https://www.jetbrains.com/webstorm\nsecureCRT\\u0026FX: https://www.vandyke.com/download/index.html\nNavicat: https://www.navicat.com.cn/download/navicat-premium\nDBeaver: https://dbeaver.io\nPostman: https://www.postman.com/downloads\nApiPost: https://www.apipost.cn/download.html\nDataGrip: https://www.jetbrains.com/datagrip\nstudio3t: https://studio3t.com/download\nRedis Desktop Manager: https://rdm.dev\nAnother Redis Desktop Manager: https://github.com/qishibo/AnotherRedisDesktopManager\nFiddler: https://www.telerik.com/download/fiddler\nBeyond Compare: https://www.scootersoftware.com/download.php\nFinalShell: https://www.hostbuf.com/t/988.html\nXMind: https://www.xmind.cn/download\nSnipPaste: https://www.snipaste.com\n\n😱 编程学习平台\nB站学习网: https://www.bilibili.com\n中国大学MOOC(慕课）: https://www.icourse163.org\n网易云课堂: https://study.163.com\n网易公开课: https://open.163.com\n码农教程: http://www.manongjc.com\n菜鸟教程: https://www.runoob.com\n易百教程: https://www.yiibai.com\nW3school: https://www.w3school.com.cn\n慕课网: https://www.imooc.com\nGitchat: https://gitbook.cn\nBootstrap中文网: https://www.bootcss.com\nGitHub: https://github.com\nGitee: https://gitee.com\nSpringBoot中文导航: http://springboot.fun\nSpringCloud中文导航: http://springcloud.fun\n技术博客: http://techblog.pub\ncoursera: https://www.coursera.org\n拉钩教育: https://kaiwu.lagou.com\n极客时间: https://time.geekbang.org\n极客学院: https://wiki.jikexueyuan.com\n人工智能教程: https://www.captainai.net/puresmilex\n百度前端技术学院: http://ife.baidu.com\n\n🤤 刷题练习网站\nLeetCode: https://leetcode-cn.com\n牛客网: https://www.nowcoder.com\nLintCode: https://www.lintcode.com\n\n😎 代码练习网站\n北京大学POJ: http://poj.org\nAlgoMooc算法慕课网: https://www.algomooc.com\n自学SQL网: http://xuesql.cn\nSQLZOO练习: https://sqlzoo.net/wiki/SQL_Tutorial/zh\n赛码: http://www.acmcoder.com/#/practice/company\nUOJ: https://uoj.ac\nHihocoder: http://hihocoder.com/problemset\n趣IT: https://www.funit.cn\n\n👨在线画图工具\nProcesson: https://www.processon.com\nDraw.io: https://app.diagrams.net\n思维导图mindline: http://www.mindline.cn/webapp\nOmnigraffle: https://www.omnigroup.com/download\n\n🦸视频工具\nVideezy: https://www.videezy.com/\nVideovo: https://www.videvo.net/\nmixkit: https://mixkit.co/\ndistill: https://wedistill.io/\n\n💃 图片（图像）处理\n图片处理（超级能耐）: https://www.iloveimg.com/zh-cn\npixabay: https://pixabay.com/zh/\nUnsplash: https://unsplash.com/\nPexels: https://www.pexels.com/zh-cn/\nFoodiesfeed : https://www.foodiesfeed.com\nCC零图片网: https://cc0.cn/\nLogo神器: https://www.logosc.cn/so/\niconfont: https://www.iconfont.cn/\n字由: https://www.hellofont.cn/\n100font: https://www.100font.com/\n\n💁 PDF免费工具\n最实用PDF工具包: https://www.ilovepdf.com/zh-cn\nLight PDF: https://lightpdf.com/zh/\nPDF格式转换: http://app.xunjiepdf.com/\n\n👨🔧 站长工具汇总\n站长之家: https://tool.chinaz.com\n百度统计: https://tongji.baidu.com\n网站排名: http://www.alexa.cn\n友盟: https://www.umeng.com/web\n阿里云ECS: https://www.aliyun.com/\n腾讯云: https://curl.qcloud.com/Rqy4Deo2\n华为云: https://www.huaweicloud.com\n极客增长: https://yinliu.club/member/KeywordHot/index\n二十次幂: https://www.cimidata.com/?refcode=PEyZMk\n大数据导航: http://hao.199it.com\n\n","categories":["其他"],"tags":["转载"]},{"title":"Flask项目配置","url":"/2022/11/11/%E7%AC%AC%E4%BA%8C%E8%8A%82%EF%BC%9A%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%20-%20Python%E6%A1%86%E6%9E%B6Flask%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%20-%20%E7%9F%A5%E4%BA%86%E4%BC%A0%E8%AF%BE/","content":"本教材由知了传课辛苦制作而成，仅供学习使用，请勿用于商业用途！如进行转载请务必注明出处！谢谢！\n项目配置一、设置为 DEBUG 模式：默认情况下flask不会开启DEBUG模式，开启DEBUG模式后，flask 会在每次保存代码的时候自动的重新载入代码，并且如果代码有错误，会在终端进行提示。如果一切正常，会在终端打印以下信息：\n* Restarting with stat\n* Debugger is active!\n* Debugger pin code: 294-745-044\n* Running on http://0.0.0.0:9000/ (Press CTRL+C to quit)\n\n\n需要注意的是，只能在开发环境下开启DEBUG模式，因为DEBUG模式会带来非常大的安全隐患。\n二、配置文件：Flask项目的配置，都是通过app.config对象来进行配置的。比如要配置一个项目的SECRET_KEY，那么可以使用app.config[&#39;SECRET_KEY&#39;] = &quot;xxx&quot;来进行设置，在Flask项目中，有四种方式进行项目的配置：\n\n直接硬编码：\napp = Flask(__name__)\napp.config['SECRET_KEY'] = \"xxx\"\n\n\n因为app.config是flask.config.Config的实例，而Config类是继承自dict，因此可以通过update方法：\napp.config.update(\n   DEBUG=True,\n   SECRET_KEY='...'\n)\n\n\n如果你的配置项特别多，你可以把所有的配置项都放在一个模块中，然后通过加载模块的方式进行配置，假设有一个settings.py模块，专门用来存储配置项的，此时你可以通过app.config.from_object()方法进行加载，并且该方法既可以接收模块的的字符串名称，也可以模块对象：\n# 1. 通过模块字符串\napp.config.from_object('settings')\n# 2. 通过模块对象\nimport settings\napp.config.from_object(settings)\n\n\n也可以通过另外一个方法加载，该方法就是app.config.from_pyfile()，该方法传入一个文件名，通常是以.py结尾的文件，但也不限于只使用.py后缀的文件：\napp.config.from_pyfile('settings.py',silent=True)\n# silent=True表示如果配置文件不存在的时候不抛出异常，默认是为False，会抛出异常。\n\nFlask项目内置了许多的配置项，所有的内置配置项，可以在这里查看。\n","categories":["开发"],"tags":["转载","Python","Flask"]}]